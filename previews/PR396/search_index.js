var documenterSearchIndex = {"docs":
[{"location":"math/knotvector/#Knot-vector","page":"Knot vector","title":"Knot vector","text":"","category":"section"},{"location":"math/knotvector/#Setup","page":"Knot vector","title":"Setup","text":"using BasicBSpline\nusing Plots\nusing InteractiveUtils  # hide","category":"section"},{"location":"math/knotvector/#Definition","page":"Knot vector","title":"Definition","text":"tip: Def.  Knot vector\nA finite sequencek = (k_1 dots k_l)is called knot vector if the sequence is broad monotonic increase, i.e. k_i le k_i+1.\n\nThere are four sutypes of AbstractKnotVector; KnotVector, UniformKnotVector, SubKnotVector, and EmptyKnotVector.\n\nsubtypes(AbstractKnotVector)\n\nThey can be constructed like this.\n\nKnotVector([1,2,3])  # `KnotVector` stores a vector with `Vector{<:Real}`\nKnotVector(1:3)\nUniformKnotVector(1:8)  # `UniformKnotVector` stores a vector with `<:AbstractRange`\nUniformKnotVector(8:-1:3)\nview(KnotVector([1,2,3]), 2:3)  # Efficient and lazy knot vector with `view`\nEmptyKnotVector()  # Sometimes `EmptyKnotVector` is useful.\nEmptyKnotVector{Float64}()\n\nThere is a useful string macro @knotvector_str that generates a KnotVector instance.\n\nknotvector\"1231123\"\n\nA knot vector can be visualized with Plots.plot.\n\nk1 = KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0])\nk2 = knotvector\"1231123\"\ngr()\nplot(k1; label=\"k1\")\nplot!(k2; label=\"k2\", offset=0.5, ylims=(-0.1,1), xticks=0:10)\nsavefig(\"knotvector.png\") # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"math/knotvector/#Operations-for-knot-vectors","page":"Knot vector","title":"Operations for knot vectors","text":"","category":"section"},{"location":"math/knotvector/#Setup-and-visualization","page":"Knot vector","title":"Setup and visualization","text":"k1 = knotvector\"1 2 1 11 2 31\"\nk2 = knotvector\"113 1 12 2 32 1  1\"\nplot(k1; offset=-0.0, label=\"k1\", xticks=1:18, yticks=nothing, legend=:right)\nplot!(k2; offset=-0.2, label=\"k2\")\nplot!(k1+k2; offset=-0.4, label=\"k1+k2\")\nplot!(2k1; offset=-0.6, label=\"2k1\")\nplot!(unique(k1); offset=-0.8, label=\"unique(k1)\")\nplot!(unique(k2); offset=-1.0, label=\"unique(k2)\")\nplot!(unique(k1+k2); offset=-1.2, label=\"unique(k1+k2)\")\nsavefig(\"knotvector_operations.png\") # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"math/knotvector/#Length-of-a-knot-vector","page":"Knot vector","title":"Length of a knot vector","text":"length(k::AbstractKnotVector)\n\nlength(k1)\nlength(k2)","category":"section"},{"location":"math/knotvector/#Addition-of-knot-vectors","page":"Knot vector","title":"Addition of knot vectors","text":"Although a knot vector is not a vector in linear algebra, but we introduce additional operator +.\n\nBase.:+(k1::KnotVector{T}, k2::KnotVector{T}) where T\n\nk1 + k2\n\nNote that the operator +(::KnotVector, ::KnotVector) is commutative. This is why we choose the + sign. We also introduce product operator cdot for knot vector.","category":"section"},{"location":"math/knotvector/#Multiplication-of-knot-vectors","page":"Knot vector","title":"Multiplication of knot vectors","text":"*(m::Integer, k::AbstractKnotVector)\n\n2*k1\n2*k2","category":"section"},{"location":"math/knotvector/#Generate-a-knot-vector-with-unique-elements","page":"Knot vector","title":"Generate a knot vector with unique elements","text":"unique(k::AbstractKnotVector)\n\nunique(k1)\nunique(k2)","category":"section"},{"location":"math/knotvector/#Inclusive-relationship-between-knot-vectors","page":"Knot vector","title":"Inclusive relationship between knot vectors","text":"Base.issubset(k::KnotVector, k′::KnotVector)\n\nunique(k1) ⊆ k1 ⊆ k2\nk1 ⊆ k1\nk2 ⊆ k1","category":"section"},{"location":"math/knotvector/#Count-knots-in-a-knot-vector","page":"Knot vector","title":"Count knots in a knot vector","text":"countknots(k::AbstractKnotVector, t::Real)\n\ncountknots(k1, 0.5)\ncountknots(k1, 1.0)\ncountknots(k1, 3.0)","category":"section"},{"location":"interpolations/#Interpolations","page":"Interpolations","title":"Interpolations","text":"Currently, BasicBSpline.jl doesn't have APIs for interpolations, but it is not hard to implement some basic interpolation algorithms with this package.","category":"section"},{"location":"interpolations/#Setup","page":"Interpolations","title":"Setup","text":"using BasicBSpline\nusing IntervalSets\nusing Random; Random.seed!(42)\nusing Plots","category":"section"},{"location":"interpolations/#Interpolation-with-cubic-B-spline","page":"Interpolations","title":"Interpolation with cubic B-spline","text":"function interpolate(xs::AbstractVector, fs::AbstractVector{T}) where T\n    # Cubic open B-spline space\n    p = 3\n    k = KnotVector(xs) + KnotVector([xs[1],xs[end]]) * p\n    P = BSplineSpace{p}(k)\n\n    # dimensions\n    m = length(xs)\n    n = dim(P)\n\n    # The interpolant function has a f''=0 property at bounds.\n    ddP = BSplineDerivativeSpace{2}(P)\n    dda = [bsplinebasis(ddP,j,xs[1]) for j in 1:n]\n    ddb = [bsplinebasis(ddP,j,xs[m]) for j in 1:n]\n\n    # Compute the interpolant function (1-dim B-spline manifold)\n    M = [bsplinebasis(P,j,xs[i]) for i in 1:m, j in 1:n]\n    M = vcat(dda', M, ddb')\n    y = vcat(zero(T), fs, zero(T))\n    return BSplineManifold(M\\y, P)\nend\n\n# Example inputs\nxs = [1, 2, 3, 4, 6, 7]\nfs = [1.3, 1.5, 2, 2.1, 1.9, 1.3]\nf = interpolate(xs,fs)\n\n# Plot\nplotly()\nscatter(xs, fs)\nplot!(t->f(t))\nsavefig(\"interpolation_cubic.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"../interpolation_cubic.html\" style=\"width:100%;height:420px;\"></object>","category":"section"},{"location":"interpolations/#Interpolation-with-linear-B-spline","page":"Interpolations","title":"Interpolation with linear B-spline","text":"function interpolate_linear(xs::AbstractVector, fs::AbstractVector{T}) where T\n    # Linear open B-spline space\n    p = 1\n    k = KnotVector(xs) + KnotVector([xs[1],xs[end]])\n    P = BSplineSpace{p}(k)\n\n    # dimensions\n    m = length(xs)\n    n = dim(P)\n\n    # Compute the interpolant function (1-dim B-spline manifold)\n    return BSplineManifold(fs, P)\nend\n\n# Example inputs\nxs = [1, 2, 3, 4, 6, 7]\nfs = [1.3, 1.5, 2, 2.1, 1.9, 1.3]\n\nf = interpolate_linear(xs,fs)\n\n# Plot\nscatter(xs, fs)\nplot!(t->f(t))\nsavefig(\"interpolation_linear.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"../interpolation_linear.html\" style=\"width:100%;height:420px;\"></object>","category":"section"},{"location":"interpolations/#Interpolation-with-periodic-B-spline","page":"Interpolations","title":"Interpolation with periodic B-spline","text":"function interpolate_periodic(xs::AbstractVector, fs::AbstractVector, ::Val{p}) where p\n    # Closed B-spline space, any polynomial degrees can be accepted\n    n = length(xs) - 1\n    period = xs[end]-xs[begin]\n    k = KnotVector(vcat(\n        xs[end-p:end-1] .- period,\n        xs,\n        xs[begin+1:begin+p] .+ period\n    ))\n    P = BSplineSpace{p}(k)\n    A = [bsplinebasis(P,j,xs[i]) for i in 1:n, j in 1:n]\n    for i in 1:p-1, j in 1:i\n        A[n+i-p+1,j] += bsplinebasis(P,j+n,xs[i+n-p+1])\n    end\n    b = A \\ fs[begin:end-1]\n    # Compute the interpolant function (1-dim B-spline manifold)\n    return BSplineManifold(vcat(b,b[1:p]), P)\nend\n\n# Example inputs\nxs = [1, 2, 3, 4, 6, 7]\nfs = [1.3, 1.5, 2, 2.1, 1.9, 1.3] # fs[1] == fs[end]\n\nf = interpolate_periodic(xs,fs,Val(2))\n\n# Plot\nscatter(xs, fs)\nplot!(t->f(mod(t-1,6)+1),1,14)\nplot!(t->f(t))\nsavefig(\"interpolation_periodic.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"../interpolation_periodic.html\" style=\"width:100%;height:420px;\"></object>\n\nNote that the periodic interpolation supports any degree of polynomial.\n\nxs = 2π*rand(10)\nsort!(push!(xs, 0, 2π))\nfs = sin.(xs)\nf1 = interpolate_periodic(xs,fs,Val(1))\nf2 = interpolate_periodic(xs,fs,Val(2))\nf3 = interpolate_periodic(xs,fs,Val(3))\nf4 = interpolate_periodic(xs,fs,Val(4))\nf5 = interpolate_periodic(xs,fs,Val(5))\nscatter(xs, fs, label=\"sampling points\")\nplot!(sin, label=\"sine curve\", color=:black)\nplot!(t->f1(t), label=\"polynomial degree 1\")\nplot!(t->f2(t), label=\"polynomial degree 2\")\nplot!(t->f3(t), label=\"polynomial degree 3\")\nplot!(t->f4(t), label=\"polynomial degree 4\")\nplot!(t->f5(t), label=\"polynomial degree 5\")\nsavefig(\"interpolation_periodic_sin.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"../interpolation_periodic_sin.html\" style=\"width:100%;height:420px;\"></object>","category":"section"},{"location":"math/bsplinebasis/#B-spline-basis-function","page":"B-spline basis function","title":"B-spline basis function","text":"","category":"section"},{"location":"math/bsplinebasis/#Setup","page":"B-spline basis function","title":"Setup","text":"using BasicBSpline\nusing Random\nusing Plots","category":"section"},{"location":"math/bsplinebasis/#Basic-properties-of-B-spline-basis-function","page":"B-spline basis function","title":"Basic properties of B-spline basis function","text":"tip: Def.  B-spline space\nB-spline basis function is defined by Cox–de Boor recursion formula.beginaligned\nB_(ipk)(t)\n=\nfract-k_ik_i+p-k_iB_(ip-1k)(t)\n+frack_i+p+1-tk_i+p+1-k_i+1B_(i+1p-1k)(t) \nB_(i0k)(t)\n=\nbegincases\n    1quad (k_ile t k_i+1)\n    0quad (textotherwise)\nendcases\nendalignedIf the denominator is zero, then the term is assumed to be zero.\n\nThe next figure shows the plot of B-spline basis functions. You can manipulate these plots on desmos graphing calculator!\n\n(Image: )\n\ninfo: Thm.  Basis of B-spline space\nThe set of functions B_(ipk)_i is a basis of B-spline space mathcalPpk.\n\nThese B-spline basis functions can be calculated with bsplinebasis₊₀.\n\np = 2\nk = KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0])\nP = BSplineSpace{p}(k)\ngr()\nplot([t->bsplinebasis₊₀(P,i,t) for i in 1:dim(P)], 0, 10, ylims=(0,1), label=false)\nsavefig(\"bsplinebasisplot.png\") # hide\nnothing # hide\n\n(Image: )\n\nThe first terms can be defined in different ways (bsplinebasis₋₀).\n\nbeginaligned\nB_(i0k)(t)\n=\nbegincases\n    1quad (k_i  t le k_i+1) \n    0quad (textotherwise)\nendcases\nendaligned\n\np = 2\nk = KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0])\nP = BSplineSpace{p}(k)\nplot([t->bsplinebasis₋₀(P,i,t) for i in 1:dim(P)], 0, 10, ylims=(0,1), label=false)\nsavefig(\"bsplinebasisplot2.png\") # hide\nnothing # hide\n\n(Image: )\n\nIn these cases, each B-spline basis function B_(i2k) is coninuous, so bsplinebasis₊₀ and bsplinebasis₋₀ are equal.","category":"section"},{"location":"math/bsplinebasis/#Support-of-B-spline-basis-function","page":"B-spline basis function","title":"Support of B-spline basis function","text":"info: Thm.  Support of B-spline basis function\nIf a B-spline spacemathcalPpk is non-degenerate, the support of its basis function is calculated as follows:operatornamesupp(B_(ipk))=k_ik_i+p+1\n\nbsplinesupport returns this interval set.\n\np = 2\nk = KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0])\nP = BSplineSpace{p}(k)\n\npl1 = plot([t->bsplinebasis₋₀(P,i,t) for i in 1:dim(P)], 0, 10, ylims=(0,1), label=false)\npl2 = plot(; yticks=nothing, legend=nothing)\nfor i in 1:dim(P)\n    plot!(pl2, bsplinesupport(P,i); offset=-i/10, linewidth=3, markersize=5, ylims=(-(dim(P)+1)/10, 1/10))\nend\nplot!(pl2, k; color=:black)\nplot(pl1, pl2; layout=grid(2, 1, heights=[0.8 ,0.2]), link=:x)\nsavefig(\"bsplinesupport.png\") # hide\nnothing # hide\n\n(Image: )\n\nbsplinesupport_R is the same as bsplinesupport.\n\npl = plot(; yticks=nothing, legend=nothing, size=(600,150))\nfor i in 1:dim(P)\n    plot!(pl, bsplinesupport_R(P,i); offset=-i/10, linewidth=3, markersize=5, ylims=(-(dim(P)+1)/10, 1/10))\nend\nplot!(pl, k; color=:black)\nsavefig(\"bsplinesupport_R.png\") # hide\nnothing # hide\n\n(Image: )\n\nHowever, bsplinesupport_I is different from bsplinesupport. It returns k_ik_i+p cap k_1+pk_l-p instead.\n\npl = plot(; yticks=nothing, legend=nothing, size=(600,150))\nfor i in 1:dim(P)\n    plot!(pl, bsplinesupport_I(P,i); offset=-i/10, linewidth=3, markersize=5, ylims=(-(dim(P)+1)/10, 1/10))\nend\nplot!(pl, k; color=:black)\nsavefig(\"bsplinesupport_I.png\") # hide\nnothing # hide\n\n(Image: )\n\nbsplinesupport(P,1), bsplinesupport_R(P,1), bsplinesupport_I(P,1)\nbsplinesupport(P,3), bsplinesupport_R(P,3), bsplinesupport_I(P,3)","category":"section"},{"location":"math/bsplinebasis/#Partition-of-unity","page":"B-spline basis function","title":"Partition of unity","text":"info: Thm.  Partition of unity\nLet B_(ipk) be a B-spline basis function, then the following equation is satisfied.beginaligned\nsum_iB_(ipk)(t) = 1  (k_p+1 le t  k_l-p) \n0 le B_(ipk)(t) le 1\nendaligned\n\np = 2\nk = KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0])\nP = BSplineSpace{p}(k)\nplot(t->sum(bsplinebasis₊₀(P,i,t) for i in 1:dim(P)), 0, 10, ylims=(-0.1, 1.1), label=\"sum of bspline basis functions\")\nplot!(k, label=\"knot vector\", legend=:inside)\nsavefig(\"sumofbsplineplot.png\") # hide\nnothing # hide\n\n(Image: )\n\nTo satisfy the partition of unity on whole interval 010, sometimes more knots will be inserted to the endpoints of the interval.\n\np = 2\nk = KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0]) + p * KnotVector([0,10])\nP = BSplineSpace{p}(k)\nplot(t->sum(bsplinebasis₊₀(P,i,t) for i in 1:dim(P)), 0, 10, ylims=(-0.1, 1.1), label=\"sum of bspline basis functions\")\nplot!(k, label=\"knot vector\", legend=:inside)\nsavefig(\"sumofbsplineplot2.png\") # hide\nnothing # hide\n\n(Image: )\n\nBut, the sum sum_i B_(ipk)(t) is not equal to 1 at t=8. Therefore, to satisfy partition of unity on closed interval k_p+1 k_l-p, the definition of first terms of B-spline basis functions are sometimes replaced:\n\nbeginaligned\nB_(i0k)(t)\n=\nbegincases\n    1quad (k_i le tk_i+1)\n    1quad (k_i  t = k_i+1=k_l)\n    0quad (textotherwise)\nendcases\nendaligned\n\np = 2\nk = KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0]) + p * KnotVector([0,10])\nP = BSplineSpace{p}(k)\nplot(t->sum(bsplinebasis(P,i,t) for i in 1:dim(P)), 0, 10, ylims=(-0.1, 1.1), label=\"sum of bspline basis functions\")\nplot!(k, label=\"knot vector\", legend=:inside)\nsavefig(\"sumofbsplineplot3.png\") # hide\nnothing # hide\n\n(Image: )\n\nHere are all of valiations of the B-spline basis function.\n\nbsplinebasis₊₀\nbsplinebasis₋₀\nbsplinebasis\nBasicBSpline.bsplinebasis₋₀I","category":"section"},{"location":"math/bsplinebasis/#differentiability-and-knot-duplications","page":"B-spline basis function","title":"Differentiability and knot duplications","text":"The differentiability of the B-spline basis function depends on the duplications on the knot vector.\n\nThe following animation shows this property.\n\n# Initialize\ngr()\nRandom.seed!(42)\nN = 10\n\n# Easing functions\nc=2/√3\nf(t) = ifelse(t>0, exp(-1/t), 0.0)\ng(t) = 1 - f(c*t) / (f(c*t) + f(c-c*t))\nh(t) = Base.clamp(1 - f((1-t)/2) / f(1/2), 0, 1)\n\n# Default knot vector\nv = 10*(1:N-1)/N + randn(N-1)*0.5\npushfirst!(v, 0)\npush!(v, 10)\n\n# Generate animation\nanim = @animate for t in 0:0.05:5\n    w = copy(v)\n    w[5] = v[4] + (g(t-0.0) + h(t-3.9)) * (v[5]-v[4])\n    w[6] = v[4] + (g(t-1.0) + h(t-3.6)) * (v[6]-v[4])\n    w[7] = v[4] + (g(t-2.0) + h(t-3.3)) * (v[7]-v[4])\n    k = KnotVector(w)\n    P0 = BSplineSpace{0}(k)\n    P1 = BSplineSpace{1}(k)\n    P2 = BSplineSpace{2}(k)\n    P3 = BSplineSpace{3}(k)\n    plot(\n        plot(P0; label=\"P0\", ylims=(0,1), color=palette(:cool,4)[1]),\n        plot(P1; label=\"P1\", ylims=(0,1), color=palette(:cool,4)[2]),\n        plot(P2; label=\"P2\", ylims=(0,1), color=palette(:cool,4)[3]),\n        plot(P3; label=\"P3\", ylims=(0,1), color=palette(:cool,4)[4]),\n        plot(k; label=\"knot vector\", ylims=(-0.1,0.02), color=:white, yticks=nothing);\n        layout=grid(5, 1, heights=[0.23 ,0.23, 0.23, 0.23, 0.08]),\n        size=(501,800)\n    )\nend\n\n# Run ffmepg to generate mp4 file\n# cmd = `ffmpeg -y -framerate 24 -i $(anim.dir)/%06d.png -c:v libx264 -pix_fmt yuv420p differentiability.mp4`\ncmd = `ffmpeg -y -framerate 24 -i $(anim.dir)/%06d.png -c:v libx264 -pix_fmt yuv420p differentiability.mp4` # hide\nout = Pipe() # hide\nerr = Pipe() # hide\nrun(pipeline(ignorestatus(cmd), stdout=out, stderr=err)) # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"math/bsplinebasis/#B-spline-basis-functions-at-specific-point","page":"B-spline basis function","title":"B-spline basis functions at specific point","text":"Sometimes, you may need the non-zero values of B-spline basis functions at specific point. The bsplinebasisall function is much more efficient than evaluating B-spline functions one by one with bsplinebasis function.\n\nP = BSplineSpace{2}(KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0]))\nt = 6.3\nplot(P; label=\"P\", ylims=(0,1))\nscatter!(fill(t,3), [bsplinebasis(P,2,t), bsplinebasis(P,3,t), bsplinebasis(P,4,t)]; markershape=:circle, markersize=10, label=\"bsplinebasis\")\nscatter!(fill(t,3), bsplinebasisall(P, 2, t); markershape=:star7, markersize=10, label=\"bsplinebasisall\")\nsavefig(\"bsplinebasis_vs_bsplinebasisall.png\") # hide\nnothing # hide\n\n(Image: )\n\nBenchmark:\n\nusing BenchmarkTools, BasicBSpline\nP = BSplineSpace{2}(KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0]))\nt = 6.3\n(bsplinebasis(P, 2, t), bsplinebasis(P, 3, t), bsplinebasis(P, 4, t))\nbsplinebasisall(P, 2, t)\n@benchmark (bsplinebasis($P, 2, $t), bsplinebasis($P, 3, $t), bsplinebasis($P, 4, $t))\n@benchmark bsplinebasisall($P, 2, $t)\n\nThe next figures illustlates the relation between domain(P), intervalindex(P,t) and bsplinebasisall(P,i,t).\n\nplotly()\nk = KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0])\n\nfor p in 1:3\n    local P\n    P = BSplineSpace{p}(k)\n    plot(P, legend=:topleft, label=\"B-spline basis (p=1)\")\n    plot!(t->intervalindex(P,t),0,10, label=\"Interval index\")\n    plot!(t->sum(bsplinebasis(P,i,t) for i in 1:dim(P)),0,10, label=\"Sum of B-spline basis\")\n    plot!(domain(P); label=\"domain\")\n    plot!(k; label=\"knot vector\")\n    plot!([t->bsplinebasisall(P,1,t)[i] for i in 1:p+1],0,10, color=:black, label=\"bsplinebasisall (i=1)\", ylim=(-1,8-2p))\n    savefig(\"bsplinebasisall-$(p).html\") # hide\n    nothing # hide\nend\n\n<object type=\"text/html\" data=\"../bsplinebasisall-1.html\" style=\"width:100%;height:420px;\"></object>\n\n<object type=\"text/html\" data=\"../bsplinebasisall-2.html\" style=\"width:100%;height:420px;\"></object>\n\n<object type=\"text/html\" data=\"../bsplinebasisall-3.html\" style=\"width:100%;height:420px;\"></object>","category":"section"},{"location":"math/bsplinebasis/#Uniform-B-spline-basis-and-uniform-distribution","page":"B-spline basis function","title":"Uniform B-spline basis and uniform distribution","text":"Let X_1 dots X_n be i.i.d. random variables with X_i sim U(01), then the probability density function of X_1+cdots+X_n can be obtained via BasicBSpline.uniform_bsplinebasis_kernel(Val(n-1),t).\n\ngr()\nN = 100000\n# polynomial degree 0\nplot1 = histogram([rand() for _ in 1:N], normalize=true, label=false)\nplot!(t->BasicBSpline.uniform_bsplinebasis_kernel(Val(0),t), label=false)\n# polynomial degree 1\nplot2 = histogram([rand()+rand() for _ in 1:N], normalize=true, label=false)\nplot!(t->BasicBSpline.uniform_bsplinebasis_kernel(Val(1),t), label=false)\n# polynomial degree 2\nplot3 = histogram([rand()+rand()+rand() for _ in 1:N], normalize=true, label=false)\nplot!(t->BasicBSpline.uniform_bsplinebasis_kernel(Val(2),t), label=false)\n# polynomial degree 3\nplot4 = histogram([rand()+rand()+rand()+rand() for _ in 1:N], normalize=true, label=false)\nplot!(t->BasicBSpline.uniform_bsplinebasis_kernel(Val(3),t), label=false)\n# plot all\nplot(plot1,plot2,plot3,plot4)\nsavefig(\"histogram-uniform.png\") # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"visualization/plotlyjs/#PlotlyJS.jl","page":"PlotlyJS.jl","title":"PlotlyJS.jl","text":"","category":"section"},{"location":"visualization/plotlyjs/#Cardioid","page":"PlotlyJS.jl","title":"Cardioid","text":"using BasicBSpline\nusing BasicBSplineFitting\nusing StaticArrays\nusing PlotlyJS\nf(t) = SVector((1+cos(t))*cos(t),(1+cos(t))*sin(t))\np = 3\nk = KnotVector(range(0,2π,15)) + p * KnotVector([0,2π]) + 2 * KnotVector([π])\nP = BSplineSpace{p}(k)\na = fittingcontrolpoints(f, P)\nM = BSplineManifold(a,  P)\n\nts = range(0,2π,250)\nxs_a = getindex.(a,1)\nys_a = getindex.(a,2)\nxs_f = getindex.(M.(ts),1)\nys_f = getindex.(M.(ts),2)\nfig = Plot(scatter(x=xs_a, y=ys_a, name=\"control points\", line_color=\"blue\", marker_size=8))\naddtraces!(fig, scatter(x=xs_f, y=ys_f, name=\"B-spline curve\", mode=\"lines\", line_color=\"red\"))\nrelayout!(fig, width=500, height=500)\nsavefig(fig,\"cardioid.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"../cardioid.html\" style=\"width:100%;height:550px;\"></object>","category":"section"},{"location":"visualization/plotlyjs/#Helix","page":"PlotlyJS.jl","title":"Helix","text":"using BasicBSpline\nusing BasicBSplineFitting\nusing StaticArrays\nusing PlotlyJS\nf(t) = SVector(cos(t),sin(t),t)\np = 3\nk = KnotVector(range(0,6π,15)) + p * KnotVector([0,6π])\nP = BSplineSpace{p}(k)\na = fittingcontrolpoints(f, P)\nM = BSplineManifold(a,  P)\n\nts = range(0,6π,250)\nxs_a = getindex.(a,1)\nys_a = getindex.(a,2)\nzs_a = getindex.(a,3)\nxs_f = getindex.(M.(ts),1)\nys_f = getindex.(M.(ts),2)\nzs_f = getindex.(M.(ts),3)\nfig = Plot(scatter3d(x=xs_a, y=ys_a, z=zs_a, name=\"control points\", line_color=\"blue\", marker_size=8))\naddtraces!(fig, scatter3d(x=xs_f, y=ys_f, z=zs_f, name=\"B-spline curve\", mode=\"lines\", line_color=\"red\"))\nrelayout!(fig, width=500, height=500)\nsavefig(fig,\"helix.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"../helix.html\" style=\"width:100%;height:550px;\"></object>","category":"section"},{"location":"math/bsplinemanifold/#B-spline-manifold","page":"B-spline manifold","title":"B-spline manifold","text":"","category":"section"},{"location":"math/bsplinemanifold/#Setup","page":"B-spline manifold","title":"Setup","text":"using BasicBSpline\nusing StaticArrays\nusing StaticArrays\nusing Plots","category":"section"},{"location":"math/bsplinemanifold/#Multi-dimensional-B-spline","page":"B-spline manifold","title":"Multi-dimensional B-spline","text":"info: Thm.  Basis of tensor product of B-spline spaces\nThe tensor product of B-spline spaces mathcalPp^1k^1otimesmathcalPp^2k^2 is a linear space with the following basis.mathcalPp^1k^1otimesmathcalPp^2k^2\n= operatorname*span_ij (B_(ip^1k^1) otimes B_(jp^2k^2))where the basis are defined as(B_(ip^1k^1) otimes B_(jp^2k^2))(t^1 t^2)\n= B_(ip^1k^1)(t^1) cdot B_(jp^2k^2)(t^2)\n\nThe next plot shows B_(3p^1k^1) otimes B_(4p^2k^2) basis function.\n\n# Define shape\nk1 = KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0])\nk2 = knotvector\"31 2  121\"\nP1 = BSplineSpace{3}(k1)\nP2 = BSplineSpace{2}(k2)\n\n# Choose indices\ni1 = 3\ni2 = 4\n\n# Visualize basis functions\nplotly()\nplot(P1; plane=:xz, label=\"P1\", color=:red)\nplot!(P2; plane=:yz, label=\"P2\", color=:green)\nplot!(k1; plane=:xz, label=\"k1\", color=:red, markersize=2)\nplot!(k2; plane=:yz, label=\"k2\", color=:green, markersize=2)\nxs = range(0,10,length=100)\nys = range(1,9,length=100)\nsurface!(xs, ys, bsplinebasis.(P1,i1,xs') .* bsplinebasis.(P2,i2,ys))\nsavefig(\"2dim-tensor-product-bspline.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"../2dim-tensor-product-bspline.html\" style=\"width:100%;height:420px;\"></object>\n\nHigher dimensional tensor products mathcalPp^1k^1otimescdotsotimesmathcalPp^dk^d are defined similarly.","category":"section"},{"location":"math/bsplinemanifold/#Definition","page":"B-spline manifold","title":"Definition","text":"B-spline manifold is a parametric representation of a shape.\n\ntip: Def.  B-spline manifold\nFor given d-dimensional B-spline basis functions B_(i^1p^1k^1) otimes cdots otimes B_(i^dp^dk^d) and given points bma_i^1 dots i^d in V, B-spline manifold is defined by the following parametrization:bmp(t^1dotst^dbma_i^1 dots i^d)\n=sum_i^1dotsi^d(B_(i^1p^1k^1) otimes cdots otimes B_(i^dp^dk^d))(t^1dotst^d) bma_i^1 dots i^dWhere bma_i^1 dots i^d are called control points.\n\nWe will also write bmp(t^1dotst^d bma), bmp(t^1dotst^d), bmp(t bma) or bmp(t) for simplicity.\n\nNote that the BSplineManifold objects are callable, and the arguments will be checked if it fits in the domain of BSplineSpace.\n\nP = BSplineSpace{2}(KnotVector([0,0,0,1,1,1]))\na = [SVector(1,0), SVector(1,1), SVector(0,1)]  # `length(a) == dim(P)`\nM = BSplineManifold(a, P)\nM(0.4)  # Calculate `sum(a[i]*bsplinebasis(P, i, 0.4) for i in 1:dim(P))`\n\nIf you need extension of BSplineManifold or don't need the arguments check, you can call unbounded_mapping.\n\nM(0.4)\nunbounded_mapping(M, 0.4)\nM(1.2)\nunbounded_mapping(M, 1.2)\n\nunbounded_mapping(M,t...) is a little bit faster than M(t...) because it does not check the domain.","category":"section"},{"location":"math/bsplinemanifold/#B-spline-curve","page":"B-spline manifold","title":"B-spline curve","text":"## 1-dim B-spline manifold\np = 2 # degree of polynomial\nk = KnotVector(1:12) # knot vector\nP = BSplineSpace{p}(k) # B-spline space\na = [SVector(i-5, 3*sin(i^2)) for i in 1:dim(P)] # control points\nM = BSplineManifold(a, P) # Define B-spline manifold\nplot(M)\nsavefig(\"1dim-manifold.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"../1dim-manifold.html\" style=\"width:100%;height:420px;\"></object>","category":"section"},{"location":"math/bsplinemanifold/#B-spline-surface","page":"B-spline manifold","title":"B-spline surface","text":"## 2-dim B-spline manifold\np = 2 # degree of polynomial\nk = KnotVector(1:8) # knot vector\nP = BSplineSpace{p}(k) # B-spline space\nrand_a = [SVector(rand(), rand(), rand()) for i in 1:dim(P), j in 1:dim(P)]\na = [SVector(2*i-6.5, 2*j-6.5, 0) for i in 1:dim(P), j in 1:dim(P)] + rand_a # random generated control points\nM = BSplineManifold(a,(P,P)) # Define B-spline manifold\nplot(M)\nsavefig(\"2dim-manifold.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"../2dim-manifold.html\" style=\"width:100%;height:420px;\"></object>\n\nParaboloid\n\nplotly()\np = 2\nk = KnotVector([-1,-1,-1,1,1,1])\nP = BSplineSpace{p}(k)\na = [SVector(i,j,2i^2+2j^2-2) for i in -1:1, j in -1:1]\nM = BSplineManifold(a,P,P)\nplot(M)\nsavefig(\"paraboloid.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"../paraboloid.html\" style=\"width:100%;height:420px;\"></object>\n\nHyperbolic paraboloid\n\nplotly()\na = [SVector(i,j,2i^2-2j^2) for i in -1:1, j in -1:1]\nM = BSplineManifold(a,P,P)\nplot(M)\nsavefig(\"hyperbolicparaboloid.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"../hyperbolicparaboloid.html\" style=\"width:100%;height:420px;\"></object>","category":"section"},{"location":"math/bsplinemanifold/#B-spline-solid","page":"B-spline manifold","title":"B-spline solid","text":"k1 = k2 = KnotVector([0,0,1,1])\nk3 = UniformKnotVector(-6:6)\nP1 = BSplineSpace{1}(k1)\nP2 = BSplineSpace{1}(k2)\nP3 = BSplineSpace{3}(k3)\ne₁(t) = SVector(cos(t),sin(t),0)\ne₂(t) = SVector(-sin(t),cos(t),0)\na = cat([[e₁(t)*i+e₂(t)*j+SVector(0,0,t) for i in 0:1, j in 0:1] for t in -2:0.5:2]..., dims=3)\nM = BSplineManifold(a,(P1,P2,P3))\nplot(M; colorbar=false)\nsavefig(\"bsplinesolid.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"../bsplinesolid.html\" style=\"width:100%;height:420px;\"></object>","category":"section"},{"location":"math/bsplinemanifold/#Affine-commutativity","page":"B-spline manifold","title":"Affine commutativity","text":"info: Thm.  Affine commutativity\nLet T be a affine transform V to W, then the following equality holds.T(bmp(t bma))\n=bmp(t T(bma))","category":"section"},{"location":"math/bsplinemanifold/#Fixing-arguments-(currying)","page":"B-spline manifold","title":"Fixing arguments (currying)","text":"Just like fixing first index such as A[3,:]::Array{1} for matrix A::Array{2}, fixing first argument M(4.3,:) will create BSplineManifold{1} for B-spline surface M::BSplineManifold{2}.\n\np = 2;\nk = KnotVector(1:8);\nP = BSplineSpace{p}(k);\na = [SVector(5i+5j+rand(), 5i-5j+rand(), rand()) for i in 1:dim(P), j in 1:dim(P)];\nM = BSplineManifold(a,(P,P));\nM isa BSplineManifold{2}\nM(:,:) isa BSplineManifold{2}\nM(4.3,:) isa BSplineManifold{1}  # Fix first argument\n\nplot(M)\nplot!(M(4.3,:), linewidth = 5, color=:cyan)\nplot!(M(4.4,:), linewidth = 5, color=:red)\nplot!(M(:,5.2), linewidth = 5, color=:green)\nsavefig(\"2dim-manifold-currying.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"../2dim-manifold-currying.html\" style=\"width:100%;height:420px;\"></object>","category":"section"},{"location":"math/bsplinespace/#B-spline-space","page":"B-spline space","title":"B-spline space","text":"","category":"section"},{"location":"math/bsplinespace/#Setup","page":"B-spline space","title":"Setup","text":"using BasicBSpline\nusing StaticArrays\nusing Plots","category":"section"},{"location":"math/bsplinespace/#Defnition","page":"B-spline space","title":"Defnition","text":"Before defining B-spline space, we'll define polynomial space with degree p.\n\ntip: Def.  Polynomial space\nPolynomial space with degree p.mathcalPp\n=leftfmathbbRtomathbbR  tmapsto a_0+a_1t^1+cdots+a_pt^p   left  \n    a_iin mathbbR\n    right\nrightThis space mathcalPp is a (p+1)-dimensional linear space.\n\nNote that tmapsto t^i_0 le i le p is a basis of mathcalPp, and also the set of Bernstein polynomial B_(ip)_i is a basis of mathcalPp.\n\nbeginaligned\nB_(ip)(t)\n=binompi-1t^i-1(1-t)^p-i+1\n(i=1 dots p+1)\nendaligned\n\nWhere binompi-1 is a binomial coefficient. You can try Bernstein polynomial on desmos graphing calculator!\n\ntip: Def.  B-spline space\nFor given polynomial degree pge 0 and knot vector k=(k_1dotsk_l), B-spline space mathcalPpk is defined as follows:mathcalPpk\n=leftfmathbbRtomathbbR   left  \n    begingathered\n        operatornamesupp(f)subseteq k_1 k_l \n        exists tildefinmathcalPp f_k_i k_i+1) = tildef_k_i k_i+1)  \n        forall t in mathbbR exists delta  0 f_(t-deltat+delta)in C^p-mathfrakn_k(t)\n    endgathered right\nright\n\nNote that each element of the space mathcalPpk is a piecewise polynomial.\n\n[TODO: fig]","category":"section"},{"location":"math/bsplinespace/#Degeneration","page":"B-spline space","title":"Degeneration","text":"tip: Def.  Degeneration\nA B-spline space non-degenerate if its degree and knot vector satisfies following property:beginaligned\nk_ik_i+p+1  (1 le i le l-p-1)\nendaligned","category":"section"},{"location":"math/bsplinespace/#Dimensions","page":"B-spline space","title":"Dimensions","text":"info: Thm.  Dimension of B-spline space\nThe B-spline space is a linear space, and if a B-spline space is non-degenerate, its dimension is calculated by:dim(mathcalPpk)= k - p -1\n\nP1 = BSplineSpace{1}(KnotVector([1,2,3,4,5,6,7]))\nP2 = BSplineSpace{1}(KnotVector([1,2,4,4,4,6,7]))\nP3 = BSplineSpace{1}(KnotVector([1,2,3,5,5,5,7]))\ndim(P1), exactdim_R(P1), exactdim_I(P1)\ndim(P2), exactdim_R(P2), exactdim_I(P2)\ndim(P3), exactdim_R(P3), exactdim_I(P3)\n\nVisualization:\n\ngr()\npl1 = plot(P1); plot!(pl1, knotvector(P1))\npl2 = plot(P2); plot!(pl2, knotvector(P2))\npl3 = plot(P3); plot!(pl3, knotvector(P3))\nplot(pl1, pl2, pl3; layout=(1,3), legend=false)\nsavefig(\"dimension-degeneration.png\") # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"math/inclusive/#Inclusive-relation-between-B-spline-spaces","page":"Inclusive relationship","title":"Inclusive relation between B-spline spaces","text":"","category":"section"},{"location":"math/inclusive/#Setup","page":"Inclusive relationship","title":"Setup","text":"using BasicBSpline\nusing StaticArrays\nusing Plots","category":"section"},{"location":"math/inclusive/#Theorem-on-[issubset](@ref)","page":"Inclusive relationship","title":"Theorem on issubset","text":"info: Thm.  Inclusive relation between B-spline spaces\nFor non-degenerate B-spline spaces, the following relationship holds.mathcalPpk\nsubseteq mathcalPpk\nLeftrightarrow (m=p-p ge 0  textand  k+mwidehatksubseteq k)","category":"section"},{"location":"math/inclusive/#Examples","page":"Inclusive relationship","title":"Examples","text":"Here are plots of the B-spline basis functions of the spaces P1, P2, P3.\n\nP1 = BSplineSpace{1}(KnotVector([1,3,6,6]))\nP2 = BSplineSpace{1}(KnotVector([1,3,5,6,6,8,9]))\nP3 = BSplineSpace{2}(KnotVector([1,1,3,3,6,6,6,8,9]))\ngr()\nplot(\n    plot(P1; ylims=(0,1), label=\"P1\"),\n    plot(P2; ylims=(0,1), label=\"P2\"),\n    plot(P3; ylims=(0,1), label=\"P3\"),\n    layout=(3,1),\n    link=:x\n)\nsavefig(\"inclusive-issubset.png\") # hide\nnothing # hide\n\n(Image: )\n\nThese spaces have the folllowing incusive relationships.\n\nP1 ⊆ P2\nP1 ⊆ P3\nP2 ⊆ P3, P3 ⊆ P2, P2 ⊆ P1, P3 ⊆ P1","category":"section"},{"location":"math/inclusive/#Definition-on-[issqsubset](@ref)","page":"Inclusive relationship","title":"Definition on issqsubset","text":"tip: Def.  Inclusive relation between B-spline spaces\nFor non-degenerate B-spline spaces, the following relationship holds.mathcalPpk\nsqsubseteqmathcalPpk\nLeftrightarrow\nmathcalPpk_k_p+1k_l-p\nsubseteqmathcalPpk_k_p+1k_l-p","category":"section"},{"location":"math/inclusive/#Examples-2","page":"Inclusive relationship","title":"Examples","text":"Here are plots of the B-spline basis functions of the spaces P1, P2, P3.\n\nP1 = BSplineSpace{1}(KnotVector([1,3,6,6]))  # Save definition as above\nP4 = BSplineSpace{1}(KnotVector([1,3,5,6,8]))\nP5 = BSplineSpace{2}(KnotVector([1,1,3,3,6,6,7,9]))\ngr()\nplot(\n    plot(P1; ylims=(0,1), label=\"P1\"),\n    plot(P4; ylims=(0,1), label=\"P4\"),\n    plot(P5; ylims=(0,1), label=\"P5\"),\n    layout=(3,1),\n    link=:x\n)\nsavefig(\"inclusive-issqsubset.png\") # hide\nnothing # hide\n\n(Image: )\n\nThese spaces have the folllowing incusive relationships.\n\nP1 ⊑ P4\nP1 ⊑ P5\nP4 ⊑ P5, P5 ⊑ P4, P4 ⊑ P1, P5 ⊑ P1","category":"section"},{"location":"math/inclusive/#Change-basis-with-a-matrix","page":"Inclusive relationship","title":"Change basis with a matrix","text":"If mathcalPpk subseteq mathcalPpk (or mathcalPpk sqsubseteq mathcalPpk), there exists a n times n matrix A which holds:\n\nbeginaligned\nB_(ipk)\n=sum_jA_ij B_(jpk) \nn=dim(mathcalPpk) \nn=dim(mathcalPpk)\nendaligned\n\nYou can calculate the change of basis matrix A with changebasis.\n\nA12 = changebasis(P1,P2)\nA13 = changebasis(P1,P3)\n\nplot(\n    plot([t->bsplinebasis₊₀(P1,i,t) for i in 1:dim(P1)], 1, 9, ylims=(0,1), legend=false),\n    plot([t->sum(A12[i,j]*bsplinebasis₊₀(P2,j,t) for j in 1:dim(P2)) for i in 1:dim(P1)], 1, 9, ylims=(0,1), legend=false),\n    plot([t->sum(A13[i,j]*bsplinebasis₊₀(P3,j,t) for j in 1:dim(P3)) for i in 1:dim(P1)], 1, 9, ylims=(0,1), legend=false),\n    layout=(3,1),\n    link=:x\n)\nsavefig(\"inclusive-issubset-matrix.png\") # hide\nnothing # hide\n\n(Image: )\n\nA14 = changebasis(P1,P4)\nA15 = changebasis(P1,P5)\n\nplot(\n    plot([t->bsplinebasis₊₀(P1,i,t) for i in 1:dim(P1)], 1, 9, ylims=(0,1), legend=false),\n    plot([t->sum(A14[i,j]*bsplinebasis₊₀(P4,j,t) for j in 1:dim(P4)) for i in 1:dim(P1)], 1, 9, ylims=(0,1), legend=false),\n    plot([t->sum(A15[i,j]*bsplinebasis₊₀(P5,j,t) for j in 1:dim(P5)) for i in 1:dim(P1)], 1, 9, ylims=(0,1), legend=false),\n    layout=(3,1),\n    link=:x\n)\nsavefig(\"inclusive-issqsubset-matrix.png\") # hide\nnothing # hide\n\n(Image: )\n\nchangebasis_R\nCalculate the matrix based on P subseteq P\nchangebasis_I\nCalculate the matrix based on P sqsubseteq P\nchangebasis\nReturn changebasis_R if P subseteq P, otherwise return changebasis_I if P sqsubseteq P.","category":"section"},{"location":"math/inclusive/#Expand-spaces-with-additional-knots-or-polynomial-degree","page":"Inclusive relationship","title":"Expand spaces with additional knots or polynomial degree","text":"There are some functions to expand spaces with additional knots or polynomial degree.\n\nexpandspace_R\nexpandspace_I\nexpandspace\n\nP = BSplineSpace{2}(knotvector\"21 113\")\nP_R = expandspace_R(P, Val(1), KnotVector([3.4, 4.2]))\nP_I = expandspace_I(P, Val(1), KnotVector([3.4, 4.2]))\nP ⊆ P_R\nP ⊆ P_I\nP ⊑ P_R\nP ⊑ P_I","category":"section"},{"location":"math/introduction/#Mathematical-properties-of-B-spline","page":"Introduction","title":"Mathematical properties of B-spline","text":"","category":"section"},{"location":"math/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"B-spline is a mathematical object, and it has a lot of application. (e.g. Geometric representation: NURBS, Interpolation, Numerical analysis: IGA)\n\nWe will explain the mathematical definitions and properties of B-spline with Julia code in the following pages.","category":"section"},{"location":"math/introduction/#Notice","page":"Introduction","title":"Notice","text":"Some of notations in this page are our original, but these are well-considered results.","category":"section"},{"location":"math/introduction/#References","page":"Introduction","title":"References","text":"Most of this documentation around B-spline is self-contained. If you want to learn more, the following resources are recommended.\n\n\"Geometric Modeling with Splines\" by Elaine Cohen, Richard F. Riesenfeld, Gershon Elber\n\"Spline Functions: Basic Theory\" by Larry Schumaker\n\n日本語の文献では以下がおすすめです。\n\nスプライン関数とその応用 by 市田浩三, 吉本富士市\nNURBS多様体による形状表現\nBasicBSpline.jlを作ったので宣伝です！\nB-spline入門（線形代数がすこし分かる人向け）","category":"section"},{"location":"visualization/basicbsplineexporter/#BasicBSplineExporter.jl","page":"BasicBSplineExporter.jl","title":"BasicBSplineExporter.jl","text":"BasicBSplineExporter.jl supports export BasicBSpline.BSplineManifold{Dim,Deg,<:StaticVector} to:\n\nPNG image (.png)\nSVG image (.png)\nPOV-Ray mesh (.inc)","category":"section"},{"location":"visualization/basicbsplineexporter/#Installation","page":"BasicBSplineExporter.jl","title":"Installation","text":"] add BasicBSplineExporter","category":"section"},{"location":"visualization/basicbsplineexporter/#First-example","page":"BasicBSplineExporter.jl","title":"First example","text":"using BasicBSpline\nusing BasicBSplineExporter\nusing StaticArrays\n\np = 2 # degree of polynomial\nk1 = KnotVector(1:8) # knot vector\nk2 = KnotVector(rand(7))+(p+1)*KnotVector([1])\nP1 = BSplineSpace{p}(k1) # B-spline space\nP2 = BSplineSpace{p}(k2)\nn1 = dim(P1) # dimension of B-spline space\nn2 = dim(P2)\na = [SVector(2i-6.5+rand(),1.5j-6.5+rand()) for i in 1:dim(P1), j in 1:dim(P2)] # random generated control points\nM = BSplineManifold(a,(P1,P2)) # Define B-spline manifold\nsave_png(\"BasicBSplineExporter_2dim.png\", M) # save image\n\n(Image: )","category":"section"},{"location":"visualization/basicbsplineexporter/#Other-examples","page":"BasicBSplineExporter.jl","title":"Other examples","text":"Here are some images rendared with POV-Ray.\n\n(Image: ) (Image: ) (Image: )\n\nSee BasicBSplineExporter.jl/test for more examples.","category":"section"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#BasicBSpline.jl","page":"API","title":"BasicBSpline.jl","text":"","category":"section"},{"location":"api/#BasicBSplineFitting.jl","page":"API","title":"BasicBSplineFitting.jl","text":"","category":"section"},{"location":"api/#BasicBSpline.AbstractKnotVector","page":"API","title":"BasicBSpline.AbstractKnotVector","text":"An abstract type for knot vector.\n\n\n\n\n\n","category":"type"},{"location":"api/#BasicBSpline.BSplineDerivativeSpace","page":"API","title":"BasicBSpline.BSplineDerivativeSpace","text":"BSplineDerivativeSpace{r}(P::BSplineSpace)\n\nConstruct derivative of B-spline space from given differential order and B-spline space.\n\nD^r(mathcalPpk)\n=leftt mapsto left fracd^r fdt^r(t)   right  f in mathcalPpk right\n\nExamples\n\njulia> P = BSplineSpace{2}(KnotVector([1,2,3,4,5,6]))\nBSplineSpace{2, Int64, KnotVector{Int64}}(KnotVector([1, 2, 3, 4, 5, 6]))\n\njulia> dP = BSplineDerivativeSpace{1}(P)\nBSplineDerivativeSpace{1, BSplineSpace{2, Int64, KnotVector{Int64}}, Int64}(BSplineSpace{2, Int64, KnotVector{Int64}}(KnotVector([1, 2, 3, 4, 5, 6])))\n\njulia> degree(P), degree(dP)\n(2, 1)\n\n\n\n\n\n","category":"type"},{"location":"api/#BasicBSpline.BSplineManifold","page":"API","title":"BasicBSpline.BSplineManifold","text":"Construct B-spline manifold from given control points and B-spline spaces.\n\nExamples\n\njulia> using StaticArrays\n\njulia> P = BSplineSpace{2}(KnotVector([0,0,0,1,1,1]))\nBSplineSpace{2, Int64, KnotVector{Int64}}(KnotVector([0, 0, 0, 1, 1, 1]))\n\njulia> a = [SVector(1,0), SVector(1,1), SVector(0,1)]\n3-element Vector{SVector{2, Int64}}:\n [1, 0]\n [1, 1]\n [0, 1]\n\njulia> M = BSplineManifold(a, P);\n\n\njulia> M(0.4)\n2-element SVector{2, Float64} with indices SOneTo(2):\n 0.84\n 0.64\n\njulia> M(1.2)\nERROR: DomainError with 1.2:\nThe input 1.2 is out of domain 0 .. 1.\n[...]\n\n\n\n\n\n","category":"type"},{"location":"api/#BasicBSpline.BSplineSpace","page":"API","title":"BasicBSpline.BSplineSpace","text":"Construct B-spline space from given polynominal degree and knot vector.\n\nmathcalPpk\n\nExamples\n\njulia> p = 2\n2\n\njulia> k = KnotVector([1,3,5,6,8,9])\nKnotVector([1, 3, 5, 6, 8, 9])\n\njulia> BSplineSpace{p}(k)\nBSplineSpace{2, Int64, KnotVector{Int64}}(KnotVector([1, 3, 5, 6, 8, 9]))\n\n\n\n\n\n","category":"type"},{"location":"api/#BasicBSpline.BSplineSpace-Union{Tuple{BSplineSpace{p, T} where T<:Real}, Tuple{p}} where p","page":"API","title":"BasicBSpline.BSplineSpace","text":"Convert BSplineSpace to BSplineSpace\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.EmptyKnotVector","page":"API","title":"BasicBSpline.EmptyKnotVector","text":"Knot vector with zero-element.\n\nk=()\n\nThis struct is intended for internal use.\n\nExamples\n\njulia> EmptyKnotVector()\nEmptyKnotVector{Bool}()\n\njulia> EmptyKnotVector{Float64}()\nEmptyKnotVector{Float64}()\n\n\n\n\n\n","category":"type"},{"location":"api/#BasicBSpline.KnotVector","page":"API","title":"BasicBSpline.KnotVector","text":"Construct knot vector from given array.\n\nk=(k_1dotsk_l)\n\nExamples\n\njulia> k = KnotVector([1,2,3])\nKnotVector([1, 2, 3])\n\njulia> k = KnotVector(1:3)\nKnotVector([1, 2, 3])\n\n\n\n\n\n","category":"type"},{"location":"api/#BasicBSpline.RationalBSplineManifold","page":"API","title":"BasicBSpline.RationalBSplineManifold","text":"Construct Rational B-spline manifold from given control points, weights and B-spline spaces.\n\nExamples\n\njulia> using StaticArrays, LinearAlgebra\n\njulia> P = BSplineSpace{2}(KnotVector([0,0,0,1,1,1]))\nBSplineSpace{2, Int64, KnotVector{Int64}}(KnotVector([0, 0, 0, 1, 1, 1]))\n\njulia> w = [1, 1/√2, 1]\n3-element Vector{Float64}:\n 1.0\n 0.7071067811865475\n 1.0\n\njulia> a = [SVector(1,0), SVector(1,1), SVector(0,1)]\n3-element Vector{SVector{2, Int64}}:\n [1, 0]\n [1, 1]\n [0, 1]\n\njulia> M = RationalBSplineManifold(a,w,P);  # 1/4 arc\n\n\njulia> M(0.3)\n2-element SVector{2, Float64} with indices SOneTo(2):\n 0.8973756499953727\n 0.4412674277525845\n\njulia> norm(M(0.3))\n1.0\n\n\n\n\n\n","category":"type"},{"location":"api/#BasicBSpline.SubKnotVector","page":"API","title":"BasicBSpline.SubKnotVector","text":"A type to represetnt sub knot vector.\n\nk=(k_1dotsk_l)\n\nExamples\n\njulia> k = knotvector\"1 11 211\"\nKnotVector([1, 3, 4, 6, 6, 7, 8])\n\njulia> view(k, 2:5)\nSubKnotVector([3, 4, 6, 6])\n\n\n\n\n\n","category":"type"},{"location":"api/#BasicBSpline.UniformKnotVector","page":"API","title":"BasicBSpline.UniformKnotVector","text":"Construct uniform knot vector from given range.\n\nk=(k_1dotsk_l)\n\nExamples\n\njulia> k = UniformKnotVector(1:8)\nUniformKnotVector(1:8)\n\njulia> UniformKnotVector(8:-1:3)\nUniformKnotVector(3:1:8)\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.:*-Tuple{Integer, AbstractKnotVector}","page":"API","title":"Base.:*","text":"Product of integer and knot vector\n\nbeginaligned\nmcdot k=underbracek+cdots+k_m\nendaligned\n\nFor example, 2cdot (1225)=(11222255).\n\nExamples\n\njulia> k = KnotVector([1,2,2,5]);\n\n\njulia> 2 * k\nKnotVector([1, 1, 2, 2, 2, 2, 5, 5])\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:+-Union{Tuple{T}, Tuple{KnotVector{T}, KnotVector{T}}} where T","page":"API","title":"Base.:+","text":"Sum of knot vectors\n\nbeginaligned\nk^(1)+k^(2)\n=(k^(1)_1 dots k^(1)_l^(1)) + (k^(2)_1 dots k^(2)_l^(2)) \n=(textsort of union of   k^(1)  textand   k^(2) text)\nendaligned\n\nFor example, (1235)+(458)=(1234558).\n\nExamples\n\njulia> k1 = KnotVector([1,2,3,5]);\n\n\njulia> k2 = KnotVector([4,5,8]);\n\n\njulia> k1 + k2\nKnotVector([1, 2, 3, 4, 5, 5, 8])\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.issubset-Tuple{KnotVector, KnotVector}","page":"API","title":"Base.issubset","text":"Check a inclusive relationship ksubseteq k, for example:\n\nbeginaligned\n(12) subseteq (123) \n(122) notsubseteq (123) \n(123) subseteq (123) \nendaligned\n\nExamples\n\njulia> KnotVector([1,2]) ⊆ KnotVector([1,2,3])\ntrue\n\njulia> KnotVector([1,2,2]) ⊆ KnotVector([1,2,3])\nfalse\n\njulia> KnotVector([1,2,3]) ⊆ KnotVector([1,2,3])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.issubset-Union{Tuple{p′}, Tuple{p}, Tuple{BSplineSpace{p, T} where T<:Real, BSplineSpace{p′, T} where T<:Real}} where {p, p′}","page":"API","title":"Base.issubset","text":"Check inclusive relationship between B-spline spaces.\n\nmathcalPpk\nsubseteqmathcalPpk\n\nExamples\n\njulia> P1 = BSplineSpace{1}(KnotVector([1,3,5,8]));\n\n\njulia> P2 = BSplineSpace{1}(KnotVector([1,3,5,6,8,9]));\n\n\njulia> P3 = BSplineSpace{2}(KnotVector([1,1,3,3,5,5,8,8]));\n\n\njulia> P1 ⊆ P2\ntrue\n\njulia> P1 ⊆ P3\ntrue\n\njulia> P2 ⊆ P3\nfalse\n\njulia> P2 ⊈ P3\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{AbstractKnotVector}","page":"API","title":"Base.length","text":"Length of knot vector\n\nbeginaligned\nk\n=(textnumber of knot elements of   k) \nendaligned\n\nFor example, (1223)=4.\n\nExamples\n\njulia> k = KnotVector([1,2,2,3]);\n\n\njulia> length(k)\n4\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.union-Tuple{KnotVector, KnotVector}","page":"API","title":"Base.union","text":"union(k1::KnotVector, k2::KnotVector) -> KnotVector\n\nConstruct a union of two knot vectors, the minimum knotvector that satisfies k1 subseteq k1cup k2 and k2 subseteq k1cup k2.\n\nExamples\n\njulia> k1 = knotvector\"12 3 1\"\nKnotVector([1, 2, 2, 4, 4, 4, 6])\n\njulia> k2 = knotvector\" 1 412\"\nKnotVector([2, 4, 4, 4, 4, 5, 6, 6])\n\njulia> k3 = knotvector\"12 412\"\nKnotVector([1, 2, 2, 4, 4, 4, 4, 5, 6, 6])\n\njulia> k1 ∪ k2 == k3\ntrue\n\njulia> k1 ⊆ k1 ∪ k2\ntrue\n\njulia> k2 ⊆ k1 ∪ k2\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.unique-Tuple{AbstractKnotVector}","page":"API","title":"Base.unique","text":"Unique elements of knot vector.\n\nbeginaligned\nwidehatk\n=(textunique knot elements of   k) \nendaligned\n\nFor example, widehat(1223)=(123).\n\nExamples\n\njulia> k = KnotVector([1,2,2,3]);\n\n\njulia> unique(k)\nKnotVector([1, 2, 3])\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.__changebasis_I","page":"API","title":"BasicBSpline.__changebasis_I","text":"__changebasis_I(P::AbstractFunctionSpace, P′::AbstractFunctionSpace)\n\nInternal function for changebasis_I.\n\nImplicit assumption:\n\nP ⊑ P′\nisnondegenerate_I(P′, 1)\nisnondegenerate_I(P′, dim(P′))\n\n\n\n\n\n","category":"function"},{"location":"api/#BasicBSpline._changebasis_I","page":"API","title":"BasicBSpline._changebasis_I","text":"_changebasis_I(P::AbstractFunctionSpace, P′::AbstractFunctionSpace)\n\nInternal function for changebasis_I.\n\nImplicit assumption:\n\nP ⊑ P′\n\n\n\n\n\n","category":"function"},{"location":"api/#BasicBSpline._changebasis_R","page":"API","title":"BasicBSpline._changebasis_R","text":"_changebasis_R(P::AbstractFunctionSpace, P′::AbstractFunctionSpace)\n\nInternal function for changebasis_R.\n\nImplicit assumption:\n\nP ⊆ P′\n\n\n\n\n\n","category":"function"},{"location":"api/#BasicBSpline._changebasis_sim-Union{Tuple{T2}, Tuple{T1}, Tuple{p}, Tuple{BSplineSpace{p, T1, K} where K<:AbstractKnotVector{T1}, BSplineSpace{p, T2, K} where K<:AbstractKnotVector{T2}}} where {p, T1, T2}","page":"API","title":"BasicBSpline._changebasis_sim","text":"Return a coefficient matrix A which satisfy\n\nB_(ip_1k_1) = sum_jA_ijB_(jp_2k_2)\n\nAssumption:\n\nP_1  P_2\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline._lower_R","page":"API","title":"BasicBSpline._lower_R","text":"Internal methods for obtaining a B-spline space with one degree lower.\n\nbeginaligned\nmathcalPpk mapsto mathcalPp-1k \nD^rmathcalPpk mapsto D^r-1mathcalPp-1k\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"api/#BasicBSpline._vec","page":"API","title":"BasicBSpline._vec","text":"Convert AbstractKnotVector to AbstractVector\n\n\n\n\n\n","category":"function"},{"location":"api/#BasicBSpline.bsplinebasis-Union{Tuple{S}, Tuple{T}, Tuple{p}, Tuple{BSplineSpace{p, T, K} where K<:AbstractKnotVector{T}, Integer, S}} where {p, T, S<:Real}","page":"API","title":"BasicBSpline.bsplinebasis","text":"i-th B-spline basis function. Modified version.\n\nbeginaligned\nB_(ipk)(t)\n=\nfract-k_ik_i+p-k_iB_(ip-1k)(t)\n+frack_i+p+1-tk_i+p+1-k_i+1B_(i+1p-1k)(t) \nB_(i0k)(t)\n=\nbegincases\n    1quad (k_i le t  k_i+1) \n    1quad (k_i  t = k_i+1=k_l) \n    0quad (textotherwise)\nendcases\nendaligned\n\nExamples\n\njulia> P = BSplineSpace{0}(KnotVector(1:6))\nBSplineSpace{0, Int64, KnotVector{Int64}}(KnotVector([1, 2, 3, 4, 5, 6]))\n\njulia> bsplinebasis.(P,1:5,(1:6)')\n5×6 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.bsplinebasisall","page":"API","title":"BasicBSpline.bsplinebasisall","text":"B-spline basis functions at point t on i-th interval.\n\nExamples\n\njulia> k = KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0])\nKnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0])\n\njulia> p = 2\n2\n\njulia> P = BSplineSpace{p}(k)\nBSplineSpace{2, Float64, KnotVector{Float64}}(KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0]))\n\njulia> t = 5.7\n5.7\n\njulia> i = intervalindex(P,t)\n2\n\njulia> bsplinebasisall(P,i,t)\n3-element SVector{3, Float64} with indices SOneTo(3):\n 0.3847272727272727\n 0.6107012987012989\n 0.00457142857142858\n\njulia> bsplinebasis.(P,i:i+p,t)\n3-element Vector{Float64}:\n 0.38472727272727264\n 0.6107012987012989\n 0.00457142857142858\n\n\n\n\n\n","category":"function"},{"location":"api/#BasicBSpline.bsplinebasis′","page":"API","title":"BasicBSpline.bsplinebasis′","text":"bsplinebasis′(::AbstractFunctionSpace, ::Integer, ::Real) -> Real\n\n1st derivative of B-spline basis function. Modified version.\n\ndotB_(ipk)(t)\n=pleft(frac1k_i+p-k_iB_(ip-1k)(t)-frac1k_i+p+1-k_i+1B_(i+1p-1k)(t)right)\n\nbsplinebasis′(P, i, t) is equivalent to bsplinebasis(derivative(P), i, t).\n\n\n\n\n\n","category":"function"},{"location":"api/#BasicBSpline.bsplinebasis′₊₀","page":"API","title":"BasicBSpline.bsplinebasis′₊₀","text":"bsplinebasis′₊₀(::AbstractFunctionSpace, ::Integer, ::Real) -> Real\n\n1st derivative of B-spline basis function. Right-sided limit version.\n\ndotB_(ipk)(t)\n=pleft(frac1k_i+p-k_iB_(ip-1k)(t)-frac1k_i+p+1-k_i+1B_(i+1p-1k)(t)right)\n\nbsplinebasis′₊₀(P, i, t) is equivalent to bsplinebasis₊₀(derivative(P), i, t).\n\n\n\n\n\n","category":"function"},{"location":"api/#BasicBSpline.bsplinebasis′₋₀","page":"API","title":"BasicBSpline.bsplinebasis′₋₀","text":"bsplinebasis′₋₀(::AbstractFunctionSpace, ::Integer, ::Real) -> Real\n\n1st derivative of B-spline basis function. Left-sided limit version.\n\ndotB_(ipk)(t)\n=pleft(frac1k_i+p-k_iB_(ip-1k)(t)-frac1k_i+p+1-k_i+1B_(i+1p-1k)(t)right)\n\nbsplinebasis′₋₀(P, i, t) is equivalent to bsplinebasis₋₀(derivative(P), i, t).\n\n\n\n\n\n","category":"function"},{"location":"api/#BasicBSpline.bsplinebasis₊₀-Union{Tuple{S}, Tuple{T}, Tuple{p}, Tuple{BSplineSpace{p, T, K} where K<:AbstractKnotVector{T}, Integer, S}} where {p, T, S<:Real}","page":"API","title":"BasicBSpline.bsplinebasis₊₀","text":"i-th B-spline basis function. Right-sided limit version.\n\nbeginaligned\nB_(ipk)(t)\n=\nfract-k_ik_i+p-k_iB_(ip-1k)(t)\n+frack_i+p+1-tk_i+p+1-k_i+1B_(i+1p-1k)(t) \nB_(i0k)(t)\n=\nbegincases\n    1quad (k_ile t k_i+1)\n    0quad (textotherwise)\nendcases\nendaligned\n\nExamples\n\njulia> P = BSplineSpace{0}(KnotVector(1:6))\nBSplineSpace{0, Int64, KnotVector{Int64}}(KnotVector([1, 2, 3, 4, 5, 6]))\n\njulia> bsplinebasis₊₀.(P,1:5,(1:6)')\n5×6 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.bsplinebasis₋₀-Union{Tuple{S}, Tuple{T}, Tuple{p}, Tuple{BSplineSpace{p, T, K} where K<:AbstractKnotVector{T}, Integer, S}} where {p, T, S<:Real}","page":"API","title":"BasicBSpline.bsplinebasis₋₀","text":"i-th B-spline basis function. Left-sided limit version.\n\nbeginaligned\nB_(ipk)(t)\n=\nfract-k_ik_i+p-k_iB_(ip-1k)(t)\n+frack_i+p+1-tk_i+p+1-k_i+1B_(i+1p-1k)(t) \nB_(i0k)(t)\n=\nbegincases\n    1quad (k_i tle k_i+1)\n    0quad (textotherwise)\nendcases\nendaligned\n\nExamples\n\njulia> P = BSplineSpace{0}(KnotVector(1:6))\nBSplineSpace{0, Int64, KnotVector{Int64}}(KnotVector([1, 2, 3, 4, 5, 6]))\n\njulia> bsplinebasis₋₀.(P,1:5,(1:6)')\n5×6 Matrix{Float64}:\n 0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.bsplinebasis₋₀I-Union{Tuple{S}, Tuple{T}, Tuple{p}, Tuple{BSplineSpace{p, T, K} where K<:AbstractKnotVector{T}, Integer, S}} where {p, T, S<:Real}","page":"API","title":"BasicBSpline.bsplinebasis₋₀I","text":"i-th B-spline basis function. Modified version (2).\n\nbeginaligned\nB_(ipk)(t)\n=\nfract-k_ik_i+p-k_iB_(ip-1k)(t)\n+frack_i+p+1-tk_i+p+1-k_i+1B_(i+1p-1k)(t) \nB_(i0k)(t)\n=\nbegincases\n    1quad (k_1+p le k_i  t le k_i+1) \n    1quad (t = k_1+p = k_i  k_i+1) \n    1quad (k_i le t  k_i+1 le k_1+p) \n    0quad (textotherwise)\nendcases\nendaligned\n\nExamples\n\njulia> P = BSplineSpace{0}(KnotVector(1:6))\nBSplineSpace{0, Int64, KnotVector{Int64}}(KnotVector([1, 2, 3, 4, 5, 6]))\n\njulia> BasicBSpline.bsplinebasis₋₀I.(P,1:5,(1:6)')\n5×6 Matrix{Float64}:\n 1.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.bsplinesupport","page":"API","title":"BasicBSpline.bsplinesupport","text":"Return the support of i-th B-spline basis function.\n\noperatornamesupp(B_(ipk))=k_ik_i+p+1\n\nExamples\n\njulia> k = KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0])\nKnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0])\n\njulia> P = BSplineSpace{2}(k)\nBSplineSpace{2, Float64, KnotVector{Float64}}(KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0]))\n\njulia> bsplinesupport(P,1)\n0.0 .. 5.5\n\njulia> bsplinesupport(P,2)\n1.5 .. 8.0\n\n\n\n\n\n","category":"function"},{"location":"api/#BasicBSpline.bsplinesupport_I-Union{Tuple{p}, Tuple{BSplineSpace{p, T} where T<:Real, Integer}} where p","page":"API","title":"BasicBSpline.bsplinesupport_I","text":"Return the support of i-th B-spline basis function.\n\noperatornamesupp(B_(ipk)_I)=k_ik_i+p+1 cap I qquad (I = k_1+p k_l-p)\n\nExamples\n\njulia> k = KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0])\nKnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0])\n\njulia> P = BSplineSpace{2}(k)\nBSplineSpace{2, Float64, KnotVector{Float64}}(KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0]))\n\njulia> bsplinesupport_I(P,1)\n2.5 .. 5.5\n\njulia> bsplinesupport_I(P,2)\n2.5 .. 8.0\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.bsplinesupport_R-Union{Tuple{p}, Tuple{BSplineSpace{p, T} where T<:Real, Integer}} where p","page":"API","title":"BasicBSpline.bsplinesupport_R","text":"Return the support of i-th B-spline basis function.\n\noperatornamesupp(B_(ipk))=k_ik_i+p+1\n\nExamples\n\njulia> k = KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0])\nKnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0])\n\njulia> P = BSplineSpace{2}(k)\nBSplineSpace{2, Float64, KnotVector{Float64}}(KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0]))\n\njulia> bsplinesupport_R(P,1)\n0.0 .. 5.5\n\njulia> bsplinesupport_R(P,2)\n1.5 .. 8.0\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.changebasis-Tuple{BasicBSpline.AbstractFunctionSpace, BasicBSpline.AbstractFunctionSpace}","page":"API","title":"BasicBSpline.changebasis","text":"changebasis(P::AbstractFunctionSpace, P′::AbstractFunctionSpace)\n\nReturn changebasis_R(P, P′) if P  P, otherwise changebasis_R(P, P′) if P  P. Throw an error if P  P and P  P.\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.changebasis_I-Tuple{BasicBSpline.AbstractFunctionSpace, BasicBSpline.AbstractFunctionSpace}","page":"API","title":"BasicBSpline.changebasis_I","text":"changebasis_I(P::AbstractFunctionSpace, P′::AbstractFunctionSpace)\n\nReturn a coefficient matrix A which satisfy\n\nB_(ipk) = sum_jA_ijB_(jpk)\n\nExamples\n\njulia> P = BSplineSpace{2}(knotvector\"3 13\")\nBSplineSpace{2, Int64, KnotVector{Int64}}(KnotVector([1, 1, 1, 3, 4, 4, 4]))\n\njulia> P′ = BSplineSpace{3}(knotvector\"4124\")\nBSplineSpace{3, Int64, KnotVector{Int64}}(KnotVector([1, 1, 1, 1, 2, 3, 3, 4, 4, 4, 4]))\n\njulia> P ⊑ P′\ntrue\n\njulia> changebasis_I(P, P′)\n4×7 SparseArrays.SparseMatrixCSC{Float64, Int32} with 13 stored entries:\n 1.0  0.666667  0.166667   ⋅         ⋅         ⋅         ⋅\n  ⋅   0.333333  0.722222  0.555556  0.111111   ⋅         ⋅\n  ⋅    ⋅        0.111111  0.444444  0.888889  0.666667   ⋅\n  ⋅    ⋅         ⋅         ⋅         ⋅        0.333333  1.0\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.changebasis_R-Tuple{BasicBSpline.AbstractFunctionSpace, BasicBSpline.AbstractFunctionSpace}","page":"API","title":"BasicBSpline.changebasis_R","text":"changebasis_R(P::AbstractFunctionSpace, P′::AbstractFunctionSpace)\n\nReturn a coefficient matrix A which satisfy\n\nB_(ipk) = sum_jA_ijB_(jpk)\n\nExamples\n\njulia> P = BSplineSpace{2}(knotvector\"3 13\")\nBSplineSpace{2, Int64, KnotVector{Int64}}(KnotVector([1, 1, 1, 3, 4, 4, 4]))\n\njulia> P′ = BSplineSpace{3}(knotvector\"4124\")\nBSplineSpace{3, Int64, KnotVector{Int64}}(KnotVector([1, 1, 1, 1, 2, 3, 3, 4, 4, 4, 4]))\n\njulia> P ⊆ P′\ntrue\n\njulia> changebasis_R(P, P′)\n4×7 SparseArrays.SparseMatrixCSC{Float64, Int32} with 13 stored entries:\n 1.0  0.666667  0.166667   ⋅         ⋅         ⋅         ⋅\n  ⋅   0.333333  0.722222  0.555556  0.111111   ⋅         ⋅\n  ⋅    ⋅        0.111111  0.444444  0.888889  0.666667   ⋅\n  ⋅    ⋅         ⋅         ⋅         ⋅        0.333333  1.0\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.countknots-Tuple{AbstractKnotVector, Real}","page":"API","title":"BasicBSpline.countknots","text":"countknots(k::AbstractKnotVector, t::Real) -> Int\n\nFor given knot vector k, the following function mathfrakn_kmathbbRtomathbbZ represents the number of knots that duplicate the knot vector k.\n\nmathfrakn_k(t) = i mid k_i=t \n\nFor example, if k=(1223), then mathfrakn_k(03)=0, mathfrakn_k(1)=1, mathfrakn_k(2)=2.\n\njulia> k = KnotVector([1,2,2,3]);\n\n\njulia> countknots(k,0.3)\n0\n\njulia> countknots(k,1.0)\n1\n\njulia> countknots(k,2.0)\n2\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.countknots-Tuple{AbstractKnotVector}","page":"API","title":"BasicBSpline.countknots","text":"countknots(k::AbstractKnotVector) -> Vector{Int}\n\nCount the duplicats of knots on the unique knot values.\n\nExamples\n\njulia> k = knotvector\"21 3\"\nKnotVector([1, 1, 2, 4, 4, 4])\n\njulia> values = collect(unique(k))\n3-element Vector{Int64}:\n 1\n 2\n 4\n\njulia> counts = countknots(k)\n3-element Vector{Int64}:\n 2\n 1\n 3\n\njulia> knotvector(values, counts)  # Equal to `k`\nKnotVector([1, 1, 2, 4, 4, 4])\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.derivative-Tuple{BSplineSpace}","page":"API","title":"BasicBSpline.derivative","text":"derivative(::BSplineDerivativeSpace{r}) -> BSplineDerivativeSpace{r+1}\nderivative(::BSplineSpace) -> BSplineDerivativeSpace{1}\n\nDerivative of B-spline related space.\n\nExamples\n\njulia> BSplineSpace{2}(KnotVector(0:5))\nBSplineSpace{2, Int64, KnotVector{Int64}}(KnotVector([0, 1, 2, 3, 4, 5]))\n\njulia> BasicBSpline.derivative(ans)\nBSplineDerivativeSpace{1, BSplineSpace{2, Int64, KnotVector{Int64}}, Int64}(BSplineSpace{2, Int64, KnotVector{Int64}}(KnotVector([0, 1, 2, 3, 4, 5])))\n\njulia> BasicBSpline.derivative(ans)\nBSplineDerivativeSpace{2, BSplineSpace{2, Int64, KnotVector{Int64}}, Int64}(BSplineSpace{2, Int64, KnotVector{Int64}}(KnotVector([0, 1, 2, 3, 4, 5])))\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.dim-Union{Tuple{BSplineSpace{p, T} where T<:Real}, Tuple{p}} where p","page":"API","title":"BasicBSpline.dim","text":"Return dimention of a B-spline space.\n\ndim(mathcalPpk)\n= k - p -1\n\nExamples\n\njulia> dim(BSplineSpace{1}(KnotVector([1,2,3,4,5,6,7])))\n5\n\njulia> dim(BSplineSpace{1}(KnotVector([1,2,4,4,4,6,7])))\n5\n\njulia> dim(BSplineSpace{1}(KnotVector([1,2,3,5,5,5,7])))\n5\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.exactdim_I-Tuple{BSplineSpace}","page":"API","title":"BasicBSpline.exactdim_I","text":"Exact dimension of a B-spline space.\n\nExamples\n\njulia> exactdim_I(BSplineSpace{1}(KnotVector([1,2,3,4,5,6,7])))\n5\n\njulia> exactdim_I(BSplineSpace{1}(KnotVector([1,2,4,4,4,6,7])))\n4\n\njulia> exactdim_I(BSplineSpace{1}(KnotVector([1,2,3,5,5,5,7])))\n3\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.exactdim_R-Tuple{BSplineSpace}","page":"API","title":"BasicBSpline.exactdim_R","text":"Exact dimension of a B-spline space.\n\nExamples\n\njulia> exactdim_R(BSplineSpace{1}(KnotVector([1,2,3,4,5,6,7])))\n5\n\njulia> exactdim_R(BSplineSpace{1}(KnotVector([1,2,4,4,4,6,7])))\n4\n\njulia> exactdim_R(BSplineSpace{1}(KnotVector([1,2,3,5,5,5,7])))\n4\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.expandspace-Union{Tuple{T}, Tuple{p₊}, Tuple{p}, Tuple{BSplineSpace{p, T, K} where K<:AbstractKnotVector{T}, Val{p₊}}, Tuple{BSplineSpace{p, T, K} where K<:AbstractKnotVector{T}, Val{p₊}, AbstractKnotVector}} where {p, p₊, T}","page":"API","title":"BasicBSpline.expandspace","text":"Expand B-spline space with given additional degree and knotvector. The behavior of expandspace is same as expandspace_I.\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.expandspace_I","page":"API","title":"BasicBSpline.expandspace_I","text":"Expand B-spline space with given additional degree and knotvector. This function is compatible with issqsubset (⊑)\n\nExamples\n\njulia> k = KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0]);\n\n\njulia> P = BSplineSpace{2}(k);\n\n\njulia> P′ = expandspace_I(P, Val(1), KnotVector([6.0]))\nBSplineSpace{3, Float64, KnotVector{Float64}}(KnotVector([0.0, 1.5, 2.5, 2.5, 5.5, 5.5, 6.0, 8.0, 8.0, 9.0, 9.0, 9.5, 10.0]))\n\njulia> P ⊆ P′\nfalse\n\njulia> P ⊑ P′\ntrue\n\njulia> domain(P)\n2.5 .. 9.0\n\njulia> domain(P′)\n2.5 .. 9.0\n\n\n\n\n\n","category":"function"},{"location":"api/#BasicBSpline.expandspace_R","page":"API","title":"BasicBSpline.expandspace_R","text":"Expand B-spline space with given additional degree and knotvector. This function is compatible with issubset (⊆).\n\nExamples\n\njulia> k = KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0]);\n\n\njulia> P = BSplineSpace{2}(k);\n\n\njulia> P′ = expandspace_R(P, Val(1), KnotVector([6.0]))\nBSplineSpace{3, Float64, KnotVector{Float64}}(KnotVector([0.0, 0.0, 1.5, 1.5, 2.5, 2.5, 5.5, 5.5, 6.0, 8.0, 8.0, 9.0, 9.0, 9.5, 9.5, 10.0, 10.0]))\n\njulia> P ⊆ P′\ntrue\n\njulia> P ⊑ P′\nfalse\n\njulia> domain(P)\n2.5 .. 9.0\n\njulia> domain(P′)\n1.5 .. 9.5\n\n\n\n\n\n","category":"function"},{"location":"api/#BasicBSpline.intervalindex-Union{Tuple{p}, Tuple{BSplineSpace{p, T} where T<:Real, Real}} where p","page":"API","title":"BasicBSpline.intervalindex","text":"Return an index of a interval in the domain of B-spline space\n\nExamples\n\njulia> k = KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0]);\n\n\njulia> P = BSplineSpace{2}(k);\n\n\njulia> domain(P)\n2.5 .. 9.0\n\njulia> intervalindex(P,2.6)\n1\n\njulia> intervalindex(P,5.6)\n2\n\njulia> intervalindex(P,8.5)\n3\n\njulia> intervalindex(P,9.5)\n3\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.isdegenerate-Tuple{BSplineSpace}","page":"API","title":"BasicBSpline.isdegenerate","text":"Check if given B-spline space is degenerate.\n\nExamples\n\njulia> isdegenerate(BSplineSpace{2}(KnotVector([1,3,5,6,8,9])))\nfalse\n\njulia> isdegenerate(BSplineSpace{1}(KnotVector([1,3,3,3,8,9])))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.isnondegenerate-Tuple{BSplineSpace}","page":"API","title":"BasicBSpline.isnondegenerate","text":"Check if given B-spline space is non-degenerate.\n\nExamples\n\njulia> isnondegenerate(BSplineSpace{2}(KnotVector([1,3,5,6,8,9])))\ntrue\n\njulia> isnondegenerate(BSplineSpace{1}(KnotVector([1,3,3,3,8,9])))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.issqsubset-Union{Tuple{p′}, Tuple{p}, Tuple{BSplineSpace{p, T} where T<:Real, BSplineSpace{p′, T} where T<:Real}} where {p, p′}","page":"API","title":"BasicBSpline.issqsubset","text":"Check inclusive relationship between B-spline spaces.\n\nmathcalPpk\nsqsubseteqmathcalPpk\nLeftrightarrow\nmathcalPpk_k_p+1k_l-p\nsubseteqmathcalPpk_k_p+1k_l-p\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.knotvector-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{<:Integer}}} where T<:Real","page":"API","title":"BasicBSpline.knotvector","text":"knotvector(values, counts) -> KnotVector\n\nConstruct a knotvector by specifying the numbers of duplicates of knots.\n\nExamples\n\n```jldoctest julia> knotvector([1, 2, 3, 4, 5], [1, 1, 1, 1, 1]) KnotVector([1, 2, 3, 4, 5])\n\njulia> knotvector([1, 2, 3], [1, 2, 3]) KnotVector([1, 2, 2, 3, 3, 3])\n\njulia> knotvector([2, 4, 6], [2, 2, 2]) KnotVector([2, 2, 4, 4, 6, 6])\n\njulia> knotvector([6], [1]) KnotVector([6])\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.r_nomial-Union{Tuple{T}, Tuple{T, T, T}} where T<:Integer","page":"API","title":"BasicBSpline.r_nomial","text":"Calculate r-nomial coefficient\n\nr_nomial(n, k, r)\n\nThis function is considered as internal.\n\n(1+x+cdots+x^r)^n = sum_k a_nkr x^k\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.refinement","page":"API","title":"BasicBSpline.refinement","text":"Refinement of B-spline manifold with given B-spline spaces.\n\n\n\n\n\n","category":"function"},{"location":"api/#BasicBSpline.refinement-Union{Tuple{Dim}, Tuple{BasicBSpline.AbstractManifold{Dim}, NTuple{Dim, Val}}, Tuple{BasicBSpline.AbstractManifold{Dim}, NTuple{Dim, Val}, NTuple{Dim, AbstractKnotVector}}} where Dim","page":"API","title":"BasicBSpline.refinement","text":"Refinement of B-spline manifold with additional degree and knotvector.\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.refinement_I-Union{Tuple{Dim}, Tuple{BasicBSpline.AbstractManifold{Dim}, NTuple{Dim, Val}}, Tuple{BasicBSpline.AbstractManifold{Dim}, NTuple{Dim, Val}, NTuple{Dim, AbstractKnotVector}}} where Dim","page":"API","title":"BasicBSpline.refinement_I","text":"Refinement of B-spline manifold with additional degree and knotvector.\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.refinement_R-Union{Tuple{Dim}, Tuple{BasicBSpline.AbstractManifold{Dim}, NTuple{Dim, Val}}, Tuple{BasicBSpline.AbstractManifold{Dim}, NTuple{Dim, Val}, NTuple{Dim, AbstractKnotVector}}} where Dim","page":"API","title":"BasicBSpline.refinement_R","text":"Refinement of B-spline manifold with additional degree and knotvector.\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSpline.unbounded_mapping","page":"API","title":"BasicBSpline.unbounded_mapping","text":"unbounded_mapping(M::BSplineManifold{Dim}, t::Vararg{Real,Dim})\n\nExamples\n\njulia> P = BSplineSpace{1}(KnotVector([0,0,1,1]))\nBSplineSpace{1, Int64, KnotVector{Int64}}(KnotVector([0, 0, 1, 1]))\n\njulia> domain(P)\n0 .. 1\n\njulia> M = BSplineManifold([0,1], P);\n\n\njulia> unbounded_mapping(M, 0.1)\n0.1\n\njulia> M(0.1)\n0.1\n\njulia> unbounded_mapping(M, 1.2)\n1.2\n\njulia> M(1.2)\nERROR: DomainError with 1.2:\nThe input 1.2 is out of domain 0 .. 1.\n[...]\n\n\n\n\n\n","category":"function"},{"location":"api/#BasicBSpline.@knotvector_str-Tuple{Any}","page":"API","title":"BasicBSpline.@knotvector_str","text":"@knotvector_str -> KnotVector\n\nConstruct a knotvector by specifying the numbers of duplicates of knots.\n\nExamples\n\njulia> knotvector\"11111\"\nKnotVector([1, 2, 3, 4, 5])\n\njulia> knotvector\"123\"\nKnotVector([1, 2, 2, 3, 3, 3])\n\njulia> knotvector\" 2 2 2\"\nKnotVector([2, 2, 4, 4, 6, 6])\n\njulia> knotvector\"     1\"\nKnotVector([6])\n\n\n\n\n\n","category":"macro"},{"location":"api/#BasicBSplineFitting.fittingcontrolpoints-Union{Tuple{Dim}, Tuple{Any, NTuple{Dim, BSplineSpace}}} where Dim","page":"API","title":"BasicBSplineFitting.fittingcontrolpoints","text":"Fitting controlpoints with least squares method.\n\nfittingcontrolpoints(func, Ps::Tuple)\n\nThis function will calculate bma_i to minimize the following integral.\n\nint_I leftf(t)-sum_i B_(ipk)(t) bma_iright^2 dt\n\nSimilarly, for the two-dimensional case, minimize the following integral.\n\nint_I^1 times I^2 leftf(t^1 t^2)-sum_ij B_(ip^1k^1)(t^1)B_(jp^2k^2)(t^2) bma_ijright^2 dt^1dt^2\n\nCurrently, this function supports up to three dimensions.\n\nExamples\n\njulia> f(t) = SVector(cos(t),sin(t),t);\n\njulia> P = BSplineSpace{3}(KnotVector(range(0,2π,30)) + 3*KnotVector([0,2π]));\n\njulia> a = fittingcontrolpoints(f, P);\n\njulia> M = BSplineManifold(a, P);\n\njulia> norm(M(1) - f(1)) < 1e-5\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSplineFitting.innerproduct_I-Union{Tuple{BSplineSpace{p, T} where T<:Real}, Tuple{p}} where p","page":"API","title":"BasicBSplineFitting.innerproduct_I","text":"Calculate a matrix\n\nA_ij=int_I B_(ipk)(t) B_(jpk)(t) dt\n\n\n\n\n\n","category":"method"},{"location":"api/#BasicBSplineFitting.innerproduct_R-Union{Tuple{BSplineSpace{p, T} where T<:Real}, Tuple{p}} where p","page":"API","title":"BasicBSplineFitting.innerproduct_R","text":"Calculate a matrix\n\nA_ij=int_mathbbR B_(ipk)(t) B_(jpk)(t) dt\n\n\n\n\n\n","category":"method"},{"location":"math/refinement/#Refinement","page":"Refinement","title":"Refinement","text":"","category":"section"},{"location":"math/refinement/#Setup","page":"Refinement","title":"Setup","text":"using BasicBSpline\nusing BasicBSplineExporter\nusing StaticArrays\nusing Plots","category":"section"},{"location":"math/refinement/#Example","page":"Refinement","title":"Example","text":"","category":"section"},{"location":"math/refinement/#Define-original-manifold","page":"Refinement","title":"Define original manifold","text":"p = 2 # degree of polynomial\nk = KnotVector(1:8) # knot vector\nP = BSplineSpace{p}(k) # B-spline space\nrand_a = [SVector(rand(), rand()) for i in 1:dim(P), j in 1:dim(P)]\na = [SVector(2*i-6.5, 2*j-6.5) for i in 1:dim(P), j in 1:dim(P)] + rand_a # random \nM = BSplineManifold(a,(P,P)) # Define B-spline manifold\ngr()\nplot(M)\nsavefig(\"refinement_2dim_original.png\") # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"math/refinement/#h-refinement-(knot-insertion)","page":"Refinement","title":"h-refinement (knot insertion)","text":"Insert additional knots to knot vectors without changing the shape.\n\nk₊ = (KnotVector([3.3,4.2]), KnotVector([3.8,3.2,5.3])) # additional knot vectors\nM_h = refinement(M, k₊) # refinement of B-spline manifold\nplot(M_h)\nsavefig(\"refinement_2dim_h.png\") # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"math/refinement/#p-refinement-(degree-elevation)","page":"Refinement","title":"p-refinement (degree elevation)","text":"Increase the polynomial degrees of B-spline manifold without changing the shape.\n\np₊ = (Val(1), Val(2)) # additional degrees\nM_p = refinement(M, p₊) # refinement of B-spline manifold\nplot(M_p)\nsavefig(\"refinement_2dim_p.png\") # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"math/rationalbsplinemanifold/#Rational-B-spline-manifold","page":"Rational B-spline manifold","title":"Rational B-spline manifold","text":"","category":"section"},{"location":"math/rationalbsplinemanifold/#Setup","page":"Rational B-spline manifold","title":"Setup","text":"using BasicBSpline\nusing StaticArrays\nusing LinearAlgebra\nusing Plots\n\nNon-uniform rational basis spline (NURBS) is also supported in BasicBSpline.jl package.","category":"section"},{"location":"math/rationalbsplinemanifold/#Definition","page":"Rational B-spline manifold","title":"Definition","text":"Rational B-spline manifold is a parametric representation of a shape.\n\ntip: Def.  Rational B-spline manifold\nFor given d-dimensional B-spline basis functions B_(i^1p^1k^1) otimes cdots otimes B_(i^dp^dk^d), given points bma_i^1 dots i^d in V and real numbers w_i^1 dots i^d  0, rational B-spline manifold is defined by the following equality:bmp(t^1dotst^d bma_i^1 dots i^d w_i^1 dots i^d)\n=sum_i^1dotsi^d\nfrac(B_(i^1p^1k^1) otimes cdots otimes B_(i^dp^dk^d))(t^1dotst^d) w_i^1 dots i^d\nsumlimits_j^1dotsj^d(B_(j^1p^1k^1) otimes cdots otimes B_(j^dp^dk^d))(t^1dotst^d) w_j^1 dots j^d\nbma_i^1 dots i^dWhere bma_i^1dotsi^d are called control points, and w_i^1 dots i^d are called weights.","category":"section"},{"location":"math/rationalbsplinemanifold/#Visualization-with-projection","page":"Rational B-spline manifold","title":"Visualization with projection","text":"A rational B-spline manifold in mathbbR^d can be understanded as a projected B-spline manifold in mathbbR^d+1. The next visuallzation this projection.\n\n# Define B-spline space\nk = KnotVector([0.0, 1.5, 2.5, 5.0, 5.5, 8.0, 9.0, 9.5, 10.0])\nP = BSplineSpace{3}(k)\n\n# Define geometric parameters\na2 = [\n    SVector(-0.65, -0.20),\n    SVector(-0.20, +0.65),\n    SVector(-0.05, -0.10),\n    SVector(+0.75, +0.20),\n    SVector(+0.45, -0.65),\n]\na3 = [SVector(p...,1) for p in a2]\nw = [2.2, 1.3, 1.9, 2.1, 1.5]\n\n# Define (rational) B-spline manifolds\nR2 = RationalBSplineManifold(a2,w,(P,))\nM3 = BSplineManifold(a3.*w,(P))\nR3 = RationalBSplineManifold(a3,w,(P,))\n\n# Plot\nplotly()\npl2 = plot(R2, xlims=(-1,1), ylims=(-1,1); color=:blue, linewidth=3, aspectratio=1, label=false)\npl3 = plot(R3; color=:blue, linewidth=3, controlpoints=(markersize=2,), label=\"Rational B-spline curve\")\nplot!(pl3, M3; color=:red, linewidth=3, controlpoints=(markersize=2,), label=\"B-spline curve\")\nfor p in a3.*w\n    plot!(pl3, [0,p[1]], [0,p[2]], [0,p[3]], color=:black, linestyle=:dash, label=false)\nend\nfor t in range(domain(P), length=51)\n    p = M3(t)\n    plot!(pl3, [0,p[1]], [0,p[2]], [0,p[3]], color=:red, linestyle=:dash, label=false)\nend\nsurface!(pl3, [-1,1], [-1,1], ones(2,2); color=:green, colorbar=false, alpha=0.5)\nplot(pl2, pl3; layout=grid(1,2, widths=[0.35, 0.65]), size=(780,500))\nsavefig(\"rational_bspline_manifold_projection.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"../rational_bspline_manifold_projection.html\" style=\"width:100%;height:520px;\"></object>","category":"section"},{"location":"math/rationalbsplinemanifold/#Conic-sections","page":"Rational B-spline manifold","title":"Conic sections","text":"One of the great aspect of rational B-spline manifolds is exact shape representation of circles. This is achieved as conic sections.","category":"section"},{"location":"math/rationalbsplinemanifold/#Arc","page":"Rational B-spline manifold","title":"Arc","text":"gr()\np = 2\nk = KnotVector([0,0,0,1,1,1])\nP = BSplineSpace{p}(k)\nt = 1  # angle in radians\na = [SVector(1,0), SVector(1,tan(t/2)), SVector(cos(t),sin(t))]\nw = [1,cos(t/2),1]\nM = RationalBSplineManifold(a,w,P)\nplot([cosd(t) for t in 0:360], [sind(t) for t in 0:360]; xlims=(-1.1,1.1), ylims=(-1.1,1.1), aspectratio=1, label=\"circle\", color=:gray, linestyle=:dash)\nplot!(M; label=\"Rational B-spline curve\")\nsavefig(\"geometricmodeling-arc.png\") # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"math/rationalbsplinemanifold/#Circle","page":"Rational B-spline manifold","title":"Circle","text":"gr()\np = 2\nk = KnotVector([0,0,0,1,1,2,2,3,3,4,4,4])\nP = BSplineSpace{p}(k)\na = [normalize(SVector(cosd(t), sind(t)), Inf) for t in 0:45:360]\nw = [ifelse(isodd(i), √2, 1) for i in 1:9]\nM = RationalBSplineManifold(a,w,P)\nplot(M, xlims=(-1.2,1.2), ylims=(-1.2,1.2), aspectratio=1)\nsavefig(\"geometricmodeling-circle.png\") # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"math/rationalbsplinemanifold/#Torus","page":"Rational B-spline manifold","title":"Torus","text":"plotly()\nR1 = 3\nR2 = 1\n\nA = push.(a, 0)\n\na1 = (R1+R2)*A\na5 = (R1-R2)*A\na2 = [p+R2*SVector(0,0,1) for p in a1]\na3 = [p+R2*SVector(0,0,1) for p in R1*A]\na4 = [p+R2*SVector(0,0,1) for p in a5]\na6 = [p-R2*SVector(0,0,1) for p in a5]\na7 = [p-R2*SVector(0,0,1) for p in R1*A]\na8 = [p-R2*SVector(0,0,1) for p in a1]\n\na = hcat(a1,a2,a3,a4,a5,a6,a7,a8,a1)\nM = RationalBSplineManifold(a,w*w',P,P)\nplot(M)\nsavefig(\"geometricmodeling-torus.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"../geometricmodeling-torus.html\" style=\"width:100%;height:420px;\"></object>","category":"section"},{"location":"math/derivative/#Derivative-of-B-spline","page":"Derivative","title":"Derivative of B-spline","text":"using BasicBSpline\nusing StaticArrays\nusing Plots\n\ninfo: Thm.  Derivative of B-spline basis function\nThe derivative of B-spline basis function can be expressed as follows:beginaligned\ndotB_(ipk)(t)\n=fracddtB_(ipk)(t) \n=pleft(frac1k_i+p-k_iB_(ip-1k)(t)-frac1k_i+p+1-k_i+1B_(i+1p-1k)(t)right)\nendalignedNote that dotB_(ipk)inmathcalPp-1k.\n\nk = KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0])\nP = BSplineSpace{3}(k)\nplotly()\nplot(\n    plot(BSplineDerivativeSpace{0}(P), label=\"0th derivative\", color=:black),\n    plot(BSplineDerivativeSpace{1}(P), label=\"1st derivative\", color=:red),\n    plot(BSplineDerivativeSpace{2}(P), label=\"2nd derivative\", color=:green),\n    plot(BSplineDerivativeSpace{3}(P), label=\"3rd derivative\", color=:blue),\n)\nsavefig(\"bsplinebasisderivativeplot.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"../bsplinebasisderivativeplot.html\" style=\"width:100%;height:420px;\"></object>","category":"section"},{"location":"#BasicBSpline.jl","page":"Home","title":"BasicBSpline.jl","text":"Basic (mathematical) operations for B-spline functions and related things with Julia.\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Aqua QA) (Image: DOI) (Image: BasicBSpline Downloads)\n\n(Image: )","category":"section"},{"location":"#Summary","page":"Home","title":"Summary","text":"This package provides basic mathematical operations for B-spline.\n\nB-spline basis function\nSome operations for knot vector\nSome operations for B-spline space (piecewise polynomial space)\nB-spline manifold (includes curve, surface and solid)\nRefinement algorithm for B-spline manifold\nFitting control points for a given function","category":"section"},{"location":"#Comparison-to-other-B-spline-packages","page":"Home","title":"Comparison to other B-spline packages","text":"There are several Julia packages for B-spline, and this package distinguishes itself with the following key benefits:\n\nSupports all degrees of polynomials.\nIncludes a refinement algorithm for B-spline manifolds.\nDelivers high-speed performance.\nIs mathematically oriented.\nProvides a fitting algorithm using least squares. (via BasicBSplineFitting.jl)\nOffers exact SVG export feature. (via BasicBSplineExporter.jl)\n\nIf you have any thoughts, please comment in:\n\nDiscourse post about BasicBSpline.jl\nJuliaPackageComparisons","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Install this package via Julia REPL's package mode.\n\n]add BasicBSpline","category":"section"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"#B-spline-basis-function","page":"Home","title":"B-spline basis function","text":"The value of B-spline basis function B_(ipk) can be obtained with bsplinebasis₊₀.\n\nbeginaligned\nB_(ipk)(t)\n=\nfract-k_ik_i+p-k_iB_(ip-1k)(t)\n+frack_i+p+1-tk_i+p+1-k_i+1B_(i+1p-1k)(t) \nB_(i0k)(t)\n=\nbegincases\n    1quad (k_ile t k_i+1)\n    0quad (textotherwise)\nendcases\nendaligned\n\njulia> using BasicBSpline\n\njulia> P3 = BSplineSpace{3}(KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0]))\nBSplineSpace{3, Float64, KnotVector{Float64}}(KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0]))\n\njulia> bsplinebasis₊₀(P3, 2, 7.5)\n0.13786213786213783\n\nBasicBSpline.jl has many recipes based on RecipesBase.jl, and BSplineSpace object can be visualized with its basis functions. (Try B-spline basis functions in Desmos)\n\nusing BasicBSpline\nusing Plots\n\nk = KnotVector([0.0, 1.5, 2.5, 5.5, 8.0, 9.0, 9.5, 10.0])\nP0 = BSplineSpace{0}(k) # 0th degree piecewise polynomial space\nP1 = BSplineSpace{1}(k) # 1st degree piecewise polynomial space\nP2 = BSplineSpace{2}(k) # 2nd degree piecewise polynomial space\nP3 = BSplineSpace{3}(k) # 3rd degree piecewise polynomial space\n\ngr()\nplot(\n    plot(P0; ylims=(0,1), label=\"P0\"),\n    plot(P1; ylims=(0,1), label=\"P1\"),\n    plot(P2; ylims=(0,1), label=\"P2\"),\n    plot(P3; ylims=(0,1), label=\"P3\"),\n    layout=(2,2),\n)\nsavefig(\"readme-cover.png\") # hide\nnothing # hide\n\n(Image: )\n\nYou can visualize the differentiability of B-spline basis function. See Differentiability and knot duplications for details.\n\n(Image: )","category":"section"},{"location":"#B-spline-manifold","page":"Home","title":"B-spline manifold","text":"using BasicBSpline\nusing StaticArrays\nusing Plots\n\n## 1-dim B-spline manifold\np = 2 # degree of polynomial\nk = KnotVector(1:12) # knot vector\nP = BSplineSpace{p}(k) # B-spline space\na = [SVector(i-5, 3*sin(i^2)) for i in 1:dim(P)] # control points\nM = BSplineManifold(a, P) # Define B-spline manifold\ngr(); plot(M)\nsavefig(\"readme-bspline_curve.png\") # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"#Rational-B-spline-manifold-(NURBS)","page":"Home","title":"Rational B-spline manifold (NURBS)","text":"using BasicBSpline\nusing LinearAlgebra\nusing StaticArrays\nusing Plots\nplotly()\n\nR1 = 3  # major radius of torus\nR2 = 1  # minor radius of torus\n\np = 2\nk = KnotVector([0,0,0,1,1,2,2,3,3,4,4,4])\nP = BSplineSpace{p}(k)\na = [normalize(SVector(cosd(t), sind(t)), Inf) for t in 0:45:360]\nw = [ifelse(isodd(i), √2, 1) for i in 1:9]\n\na0 = push.(a, 0)\na1 = (R1+R2)*a0\na5 = (R1-R2)*a0\na2 = [p+R2*SVector(0,0,1) for p in a1]\na3 = [p+R2*SVector(0,0,1) for p in R1*a0]\na4 = [p+R2*SVector(0,0,1) for p in a5]\na6 = [p-R2*SVector(0,0,1) for p in a5]\na7 = [p-R2*SVector(0,0,1) for p in R1*a0]\na8 = [p-R2*SVector(0,0,1) for p in a1]\n\nM = RationalBSplineManifold(hcat(a1,a2,a3,a4,a5,a6,a7,a8,a1), w*w', P, P)\nplot(M; controlpoints=(markersize=2,))\nsavefig(\"readme-rational_bspline_surface_plotly.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"readme-rational_bspline_surface_plotly.html\" style=\"width:100%;height:420px;\"></object>","category":"section"},{"location":"#Refinement","page":"Home","title":"Refinement","text":"","category":"section"},{"location":"#h-refinement-(knot-insertion)","page":"Home","title":"h-refinement (knot insertion)","text":"Insert additional knots to knot vectors without changing the shape.\n\nk₊ = (KnotVector([3.1, 3.2, 3.3]), KnotVector([0.5, 0.8, 0.9])) # additional knot vectors\nM_h = refinement(M, k₊) # refinement of B-spline manifold\nplot(M_h; controlpoints=(markersize=2,))\nsavefig(\"readme-rational_bspline_surface_href_plotly.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"readme-rational_bspline_surface_href_plotly.html\" style=\"width:100%;height:420px;\"></object>","category":"section"},{"location":"#p-refinement-(degree-elevation)","page":"Home","title":"p-refinement (degree elevation)","text":"Increase the polynomial degrees of B-spline manifold without changing the shape.\n\np₊ = (Val(1), Val(2)) # additional degrees\nM_p = refinement(M, p₊) # refinement of B-spline manifold\nplot(M_p; controlpoints=(markersize=2,))\nsavefig(\"readme-rational_bspline_surface_pref_plotly.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"readme-rational_bspline_surface_pref_plotly.html\" style=\"width:100%;height:420px;\"></object>","category":"section"},{"location":"#Fitting-B-spline-manifold","page":"Home","title":"Fitting B-spline manifold","text":"The next example shows the fitting for the following graph on Desmos graphing calculator!\n\n(Image: )\n\nusing BasicBSplineFitting\n\np1 = 2\np2 = 2\nk1 = KnotVector(-10:10)+p1*KnotVector([-10,10])\nk2 = KnotVector(-10:10)+p2*KnotVector([-10,10])\nP1 = BSplineSpace{p1}(k1)\nP2 = BSplineSpace{p2}(k2)\n\nf(u1, u2) = SVector(2u1 + sin(u1) + cos(u2) + u2 / 2, 3u2 + sin(u2) + sin(u1) / 2 + u1^2 / 6) / 5\n\na = fittingcontrolpoints(f, (P1, P2))\nM = BSplineManifold(a, (P1, P2))\ngr()\nplot(M; aspectratio=1)\nsavefig(\"readme-fitting.png\") # hide\nnothing # hide\n\n(Image: )\n\nIf the knot vector span is too coarse, the approximation will be coarse.\n\np1 = 2\np2 = 2\nk1 = KnotVector(-10:5:10)+p1*KnotVector([-10,10])\nk2 = KnotVector(-10:5:10)+p2*KnotVector([-10,10])\nP1 = BSplineSpace{p1}(k1)\nP2 = BSplineSpace{p2}(k2)\n\nf(u1, u2) = SVector(2u1 + sin(u1) + cos(u2) + u2 / 2, 3u2 + sin(u2) + sin(u1) / 2 + u1^2 / 6) / 5\n\na = fittingcontrolpoints(f, (P1, P2))\nM = BSplineManifold(a, (P1, P2))\nplot(M; aspectratio=1)\nsavefig(\"readme-fitting_coarse.png\") # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"#Draw-smooth-vector-graphics","page":"Home","title":"Draw smooth vector graphics","text":"using BasicBSpline\nusing BasicBSplineFitting\nusing BasicBSplineExporter\np = 3\nk = KnotVector(range(-2π,2π,length=8))+p*KnotVector([-2π,2π])\nP = BSplineSpace{p}(k)\n\nf(u) = SVector(u,sin(u))\n\na = fittingcontrolpoints(f, P)\nM = BSplineManifold(a, P)\nsave_svg(\"sine-curve.svg\", M, unitlength=50, xlims=(-8,8), ylims=(-2,2))\nsave_svg(\"sine-curve_no-points.svg\", M, unitlength=50, xlims=(-8,8), ylims=(-2,2), points=false)\n\n(Image: ) (Image: )\n\nThis is useful when you edit graphs (or curves) with your favorite vector graphics editor.\n\n(Image: )\n\nSee Plotting smooth graphs with Julia for more tutorials.","category":"section"},{"location":"math/fitting/#Fitting-with-B-spline-manifold","page":"Fitting","title":"Fitting with B-spline manifold","text":"","category":"section"},{"location":"math/fitting/#Setup","page":"Fitting","title":"Setup","text":"using BasicBSpline\nusing BasicBSplineFitting\nusing StaticArrays\nusing Plots","category":"section"},{"location":"math/fitting/#Fitting-with-least-squares","page":"Fitting","title":"Fitting with least squares","text":"fittingcontrolpoints function\n\np1 = 2\np2 = 2\nk1 = KnotVector(-10:10)+p1*KnotVector([-10,10])\nk2 = KnotVector(-10:10)+p2*KnotVector([-10,10])\nP1 = BSplineSpace{p1}(k1)\nP2 = BSplineSpace{p2}(k2)\n\nf(u1, u2) = SVector(2u1 + sin(u1) + cos(u2) + u2 / 2, 3u2 + sin(u2) + sin(u1) / 2 + u1^2 / 6) / 5\n\na = fittingcontrolpoints(f, (P1, P2))\nM = BSplineManifold(a, (P1, P2))\ngr()\nplot(M; xlims=(-10,10), ylims=(-10,10), aspectratio=1)\nsavefig(\"fitting.png\") # hide\nnothing # hide\n\n(Image: )\n\nTry on Desmos graphing graphing calculator! (Image: )","category":"section"},{"location":"math/fitting/#Cardioid-(planar-curve)","page":"Fitting","title":"Cardioid (planar curve)","text":"f(t) = SVector((1+cos(t))*cos(t),(1+cos(t))*sin(t))\np = 3\nk = KnotVector(range(0,2π,15)) + p * KnotVector([0,2π]) + 2 * KnotVector([π])\nP = BSplineSpace{p}(k)\na = fittingcontrolpoints(f, P)\nM = BSplineManifold(a, P)\n\ngr()\nplot(M; aspectratio=1)\nsavefig(\"plots-cardioid.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"../plots-cardioid.html\" style=\"width:100%;height:550px;\"></object>","category":"section"},{"location":"math/fitting/#Helix-(spatial-curve)","page":"Fitting","title":"Helix (spatial curve)","text":"f(t) = SVector(cos(t),sin(t),t)\np = 3\nk = KnotVector(range(0,6π,15)) + p * KnotVector([0,6π])\nP = BSplineSpace{p}(k)\na = fittingcontrolpoints(f, P)\nM = BSplineManifold(a, P)\n\nplotly()\nplot(M)\nsavefig(\"plots-helix.html\") # hide\nnothing # hide\n\n<object type=\"text/html\" data=\"../plots-helix.html\" style=\"width:100%;height:550px;\"></object>","category":"section"}]
}
