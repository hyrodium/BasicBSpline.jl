<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mathematical properties of B-spline ¬∑ BasicBSpline.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://hyrodium.github.io/BasicBSpline.jl/stable/math/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="BasicBSpline.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="BasicBSpline.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">BasicBSpline.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Mathematical properties of B-spline</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Knot-vector"><span>Knot vector</span></a></li><li><a class="tocitem" href="#B-spline-space"><span>B-spline space</span></a></li><li><a class="tocitem" href="#B-spline-basis-function"><span>B-spline basis function</span></a></li><li><a class="tocitem" href="#Support-of-B-spline-basis-function"><span>Support of B-spline basis function</span></a></li><li><a class="tocitem" href="#Derivative-of-B-spline-basis-function"><span>Derivative of B-spline basis function</span></a></li><li><a class="tocitem" href="#Partition-of-unity"><span>Partition of unity</span></a></li><li><a class="tocitem" href="#Inclusive-relation-between-B-spline-spaces"><span>Inclusive relation between B-spline spaces</span></a></li><li><a class="tocitem" href="#Multi-dimensional-B-spline"><span>Multi-dimensional B-spline</span></a></li><li><a class="tocitem" href="#B-spline-manifold"><span>B-spline manifold</span></a></li><li><a class="tocitem" href="#Affine-commutativity"><span>Affine commutativity</span></a></li><li><a class="tocitem" href="#Refinement"><span>Refinement</span></a></li><li><a class="tocitem" href="#Fitting"><span>Fitting</span></a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Mathematical properties of B-spline</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mathematical properties of B-spline</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/hyrodium/BasicBSpline.jl/blob/master/docs/src/math.md#L" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Mathematical-properties-of-B-spline"><a class="docs-heading-anchor" href="#Mathematical-properties-of-B-spline">Mathematical properties of B-spline</a><a id="Mathematical-properties-of-B-spline-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-properties-of-B-spline" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p><a href="https://en.wikipedia.org/wiki/B-spline">B-spline</a> is a mathematical object, and it has a lot of application. (e.g. <a href="https://en.wikipedia.org/wiki/Non-uniform_rational_B-spline">NURBS</a>, <a href="https://en.wikipedia.org/wiki/Isogeometric_analysis">IGA</a>)</p><p>In this page, we&#39;ll explain the mathematical definition and property of B-spline with Julia code. Before running the following code, you need to import the package:</p><pre><code class="language-julia hljs">using BasicBSpline</code></pre><h3 id="Notice"><a class="docs-heading-anchor" href="#Notice">Notice</a><a id="Notice-1"></a><a class="docs-heading-anchor-permalink" href="#Notice" title="Permalink"></a></h3><ul><li>A book <a href="https://www.routledge.com/p/book/9780367447243">&quot;Geometric Modeling with Splines&quot;</a> by Elaine Cohen, Richard F. Riesenfeld, Gershon Elber is really recommended.</li><li><strong>Some of notations in this page are our original</strong>, but these are well-considered results.</li></ul><h2 id="Knot-vector"><a class="docs-heading-anchor" href="#Knot-vector">Knot vector</a><a id="Knot-vector-1"></a><a class="docs-heading-anchor-permalink" href="#Knot-vector" title="Permalink"></a></h2><div class="admonition is-success"><header class="admonition-header">Def.  Knot vector</header><div class="admonition-body"><p>A finite sequence</p><p class="math-container">\[k = (k_1, \dots, k_l)\]</p><p>is called <strong>knot vector</strong> if the sequence is broad monotonic increase, i.e. <span>$k_{i} \le k_{i+1}$</span>.</p></div></div><p>[TODO: fig]</p><article class="docstring"><header><a class="docstring-binding" id="BasicBSpline.KnotVector" href="#BasicBSpline.KnotVector"><code>BasicBSpline.KnotVector</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Construct knot vector from given array.</p><p class="math-container">\[k=(k_1,\dots,k_l)\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; k = KnotVector([1,2,3])
KnotVector([1.0, 2.0, 3.0])

julia&gt; k = KnotVector(1:3)
KnotVector([1.0, 2.0, 3.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyrodium/BasicBSpline.jl/blob/f070cbf0ed614a873ce2e11b9994fa5e67d7e813/src/_KnotVector.jl#LL5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BasicBSpline.KnotVector-Tuple{Real}" href="#BasicBSpline.KnotVector-Tuple{Real}"><code>BasicBSpline.KnotVector</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Construct knot vector from given real numbers.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; k = KnotVector(1,2,3)
KnotVector([1.0, 2.0, 3.0])

julia&gt; k = KnotVector()
KnotVector([])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyrodium/BasicBSpline.jl/blob/f070cbf0ed614a873ce2e11b9994fa5e67d7e813/src/_KnotVector.jl#LL36-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{KnotVector}" href="#Base.length-Tuple{KnotVector}"><code>Base.length</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Length of knot vector</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; k = KnotVector(1,2,3,5);

julia&gt; length(k)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyrodium/BasicBSpline.jl/blob/f070cbf0ed614a873ce2e11b9994fa5e67d7e813/src/_KnotVector.jl#LL130-L140">source</a></section></article><p>Although a knot vector is <strong>not</strong> a vector in linear algebra, but we introduce <strong>additional operator</strong> <span>$+$</span>.</p><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Union{Tuple{T}, Tuple{KnotVector{T}, KnotVector{T}}} where T" href="#Base.:+-Union{Tuple{T}, Tuple{KnotVector{T}, KnotVector{T}}} where T"><code>Base.:+</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Sum of knot vectors</p><p class="math-container">\[\begin{aligned}
k^{(1)}+k^{(2)}
&amp;=(k^{(1)}_1, \dots, k^{(1)}_{l^{(1)}}) + (k^{(2)}_1, \dots, k^{(2)}_{l^{(2)}}) \\
&amp;=(\text{sort of union of} \  k^{(1)} \ \text{and} \  k^{(2)} \text{)}
\end{aligned}\]</p><p>For example, <span>$(1,2,3,5)+(4,5,8)=(1,2,3,4,5,5,8)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; k1 = KnotVector(1,2,3,5);

julia&gt; k2 = KnotVector(4,5,8);

julia&gt; k1 + k2
KnotVector([1.0, 2.0, 3.0, 4.0, 5.0, 5.0, 8.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyrodium/BasicBSpline.jl/blob/f070cbf0ed614a873ce2e11b9994fa5e67d7e813/src/_KnotVector.jl#LL70-L92">source</a></section></article><p>And <strong>product operator</strong> <span>$\cdot$</span>.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>*(n::Integer, k::KnotVector)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Base.unique-Tuple{KnotVector}" href="#Base.unique-Tuple{KnotVector}"><code>Base.unique</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Unique elements of knot vector.</p><p class="math-container">\[\begin{aligned}
\widehat{k}
&amp;=(\text{unique knot elements of} \  k) \\
\end{aligned}\]</p><p>For example, <span>$\widehat{(1,2,2,3)}=(1,2,3)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; k = KnotVector([1,2,2,3]);

julia&gt; unique(k)
KnotVector([1.0, 2.0, 3.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyrodium/BasicBSpline.jl/blob/f070cbf0ed614a873ce2e11b9994fa5e67d7e813/src/_KnotVector.jl#LL146-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BasicBSpline.ùî´-Tuple{KnotVector, Real}" href="#BasicBSpline.ùî´-Tuple{KnotVector, Real}"><code>BasicBSpline.ùî´</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>For given knot vector <span>$k$</span>, the following function <span>$\mathfrak{n}_k:\mathbb{R}\to\mathbb{Z}$</span> represents the number of knots that duplicate the knot vector <span>$k$</span>.</p><p class="math-container">\[\mathfrak{n}_k(t) = \sharp\{i \mid k_i=t \}\]</p><p>For example, if <span>$k=(1,2,2,3)$</span>, then <span>$\mathfrak{n}_k(0.3)=0$</span>, <span>$\mathfrak{n}_k(1)=1$</span>, <span>$\mathfrak{n}_k(2)=2$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; k = KnotVector([1,2,2,3]);

julia&gt; ùî´(k,0.3)
0

julia&gt; ùî´(k,1.0)
1

julia&gt; ùî´(k,2.0)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyrodium/BasicBSpline.jl/blob/f070cbf0ed614a873ce2e11b9994fa5e67d7e813/src/_KnotVector.jl#LL194-L214">source</a></section></article><h2 id="B-spline-space"><a class="docs-heading-anchor" href="#B-spline-space">B-spline space</a><a id="B-spline-space-1"></a><a class="docs-heading-anchor-permalink" href="#B-spline-space" title="Permalink"></a></h2><p>Before defining B-spline space, we&#39;ll define polynomial space with degree <span>$p$</span>.</p><div class="admonition is-success"><header class="admonition-header">Def.  Polynomial space</header><div class="admonition-body"><p>Polynomial space with degree <span>$p$</span>.</p><p class="math-container">\[\mathcal{P}[p]
=\left\{f:\mathbb{R}\to\mathbb{R}\ ;\ t\mapsto a_0+a_1t^1+\cdots+a_pt^p \  \left| \ %
    a_i\in \mathbb{R}
    \right.
\right\}\]</p><p>This space <span>$\mathcal{P}[p]$</span> is a <span>$(p+1)$</span>-dimensional linear space.</p></div></div><p>Note that <span>$\{t\mapsto t^i\}_{0 \le i \le p}$</span> is a basis of <span>$\mathcal{P}[p]$</span>, and also the set of <a href="https://en.wikipedia.org/wiki/Bernstein_polynomial">Bernstein polynomial</a> <span>$\{B_{(i,p)}\}_i$</span> is a basis of <span>$\mathcal{P}[p]$</span>.</p><p class="math-container">\[\begin{aligned}
B_{(i,p)}(t)
&amp;=\binom{p}{i-1}t^{i-1}(1-t)^{p-i+1}
&amp;(i=1, \dots, p+1)
\end{aligned}\]</p><p>Where <span>$\binom{p}{i-1}$</span> is a <a href="https://en.wikipedia.org/wiki/Binomial_coefficient">binomial coefficient</a>.</p><div class="admonition is-success"><header class="admonition-header">Def.  B-spline space</header><div class="admonition-body"><p>For given polynomial degree <span>$p\ge 0$</span> and knot vector <span>$k=(k_1,\dots,k_l)$</span>, B-spline space <span>$\mathcal{P}[p,k]$</span> is defined as follows:</p><p class="math-container">\[\mathcal{P}[p,k]
=\left\{f:\mathbb{R}\to\mathbb{R} \  \left| \ %
    \begin{gathered}
        \operatorname{supp}(f)\subseteq [k_1, k_l] \\
        \exists \tilde{f}\in\mathcal{P}[p], f|_{[k_{i}, k_{i+1})} = \tilde{f}|_{[k_{i}, k_{i+1})}  \\
        \forall t \in \mathbb{R}, \exists \delta &gt; 0, f|_{(t-\delta,t+\delta)}\in C^{p-\mathfrak{n}_k(t)}
    \end{gathered} \right.
\right\}\]</p></div></div><p>Note that each element of the space <span>$\mathcal{P}[p,k]$</span> is a piecewise polynomial.</p><p>[TODO: fig]</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = 2</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; k = KnotVector([1,3,5,6,8,9])</code><code class="nohighlight hljs ansi" style="display:block;">KnotVector([1.0, 3.0, 5.0, 6.0, 8.0, 9.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; BSplineSpace{p}(k)</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{2, Float64}(KnotVector([1.0, 3.0, 5.0, 6.0, 8.0, 9.0]))</code></pre><p>A B-spline space is said to be <strong>proper</strong> if its degree and knotvector satisfies following property:</p><p class="math-container">\[\begin{aligned}
k_{i}&amp;&lt;k_{i+p+1} &amp; (1 \le i \le l-p-1)
\end{aligned}\]</p><article class="docstring"><header><a class="docstring-binding" id="BasicBSpline.isproper" href="#BasicBSpline.isproper"><code>BasicBSpline.isproper</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>Check if given B-spline space is proper.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isproper(BSplineSpace{2}(KnotVector([1,3,5,6,8,9])))
true

julia&gt; isproper(BSplineSpace{1}(KnotVector([1,3,3,3,8,9])))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyrodium/BasicBSpline.jl/blob/f070cbf0ed614a873ce2e11b9994fa5e67d7e813/src/_BSplineSpace.jl#LL113-L124">source</a></section></article><p>The B-spline space is a linear space, and if a B-spline space is proper, its dimension is calculated by:</p><p class="math-container">\[\dim(\mathcal{P}[p,k])=\sharp k - p -1\]</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(BSplineSpace{2}(KnotVector([1,3,5,6,8,9])))</code><code class="nohighlight hljs ansi" style="display:block;">3</code></pre><article class="docstring"><header><a class="docstring-binding" id="BasicBSpline.dim" href="#BasicBSpline.dim"><code>BasicBSpline.dim</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>Return dimention of a B-spline space.</p><p class="math-container">\[\dim(\mathcal{P}[p,k])
=\sharp k - p -1\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyrodium/BasicBSpline.jl/blob/f070cbf0ed614a873ce2e11b9994fa5e67d7e813/src/_BSplineSpace.jl#LL46-L52">source</a></section></article><h2 id="B-spline-basis-function"><a class="docs-heading-anchor" href="#B-spline-basis-function">B-spline basis function</a><a id="B-spline-basis-function-1"></a><a class="docs-heading-anchor-permalink" href="#B-spline-basis-function" title="Permalink"></a></h2><div class="admonition is-success"><header class="admonition-header">Def.  B-spline space</header><div class="admonition-body"><p>B-spline basis function is defined by <a href="https://en.wikipedia.org/wiki/De_Boor%27s_algorithm">Cox‚Äìde Boor recursion formula</a>.</p><p class="math-container">\[\begin{aligned}
{B}_{(i,p,k)}(t)
&amp;=
\frac{t-k_{i}}{k_{i+p}-k_{i}}{B}_{(i,p-1,k)}(t)
+\frac{k_{i+p+1}-t}{k_{i+p+1}-k_{i+1}}{B}_{(i+1,p-1,k)}(t) \\
{B}_{(i,0,k)}(t)
&amp;=
\begin{cases}
    &amp;1\quad (k_{i}\le t&lt; k_{i+1})\\
    &amp;0\quad (\text{otherwise})
\end{cases}
\end{aligned}\]</p><p>If the denominator is zero, then the term is assumed to be zero.</p></div></div><div class="admonition is-info"><header class="admonition-header">Thm.  Basis of B-spline space</header><div class="admonition-body"><p>The set of functions <span>$\{B_{(i,p,k)}\}_i$</span> is a basis of B-spline space <span>$\mathcal{P}[p,k]$</span>.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Plots</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = 2</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; k = KnotVector(1:8)</code><code class="nohighlight hljs ansi" style="display:block;">KnotVector([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = BSplineSpace{p}(k)</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{2, Float64}(KnotVector([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot([t-&gt;bsplinebasis‚Çä‚ÇÄ(P,i,t) for i in 1:dim(P)], 1, 8, ylims=(0,1))</code><code class="nohighlight hljs ansi" style="display:block;">Plot{Plots.GRBackend() n=5}</code></pre><p><img src="../img/bsplinebasisplot.png" alt/></p><p>You can choose the first terms in different ways.</p><p class="math-container">\[\begin{aligned}
{B}_{(i,0,k)}(t)
&amp;=
\begin{cases}
    &amp;1\quad (k_{i} &lt; t \le k_{i+1}) \\
    &amp;0\quad (\text{otherwise})
\end{cases}
\end{aligned}\]</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Plots</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = 2</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; k = KnotVector(1:8)</code><code class="nohighlight hljs ansi" style="display:block;">KnotVector([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = BSplineSpace{p}(k)</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{2, Float64}(KnotVector([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot([t-&gt;bsplinebasis‚Çã‚ÇÄ(P,i,t) for i in 1:dim(P)], 1, 8, ylims=(0,1))</code><code class="nohighlight hljs ansi" style="display:block;">Plot{Plots.GRBackend() n=5}</code></pre><p><img src="../img/bsplinebasisplot.png" alt/></p><h2 id="Support-of-B-spline-basis-function"><a class="docs-heading-anchor" href="#Support-of-B-spline-basis-function">Support of B-spline basis function</a><a id="Support-of-B-spline-basis-function-1"></a><a class="docs-heading-anchor-permalink" href="#Support-of-B-spline-basis-function" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Thm.  Support of B-spline basis function</header><div class="admonition-body"><p>If a B-spline space<span>$\mathcal{P}[p,k]$</span> is proper, the support of its basis function is calculated as follows:</p><p class="math-container">\[\operatorname{supp}(B_{(i,p,k)})=[k_{i},k_{i+p+1}]\]</p></div></div><p>[TODO: fig]</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; i = 2</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; k = KnotVector([5,12,13,13,14])</code><code class="nohighlight hljs ansi" style="display:block;">KnotVector([5.0, 12.0, 13.0, 13.0, 14.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = 2</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = BSplineSpace{p}(k)</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{2, Float64}(KnotVector([5.0, 12.0, 13.0, 13.0, 14.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bsplinesupport(P) # [5..13, 12..14]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{IntervalSets.ClosedInterval{Float64}}:
 5.0..13.0
 12.0..14.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bsplinesupport(P,i) # 12..14</code><code class="nohighlight hljs ansi" style="display:block;">12.0..14.0</code></pre><h2 id="Derivative-of-B-spline-basis-function"><a class="docs-heading-anchor" href="#Derivative-of-B-spline-basis-function">Derivative of B-spline basis function</a><a id="Derivative-of-B-spline-basis-function-1"></a><a class="docs-heading-anchor-permalink" href="#Derivative-of-B-spline-basis-function" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Thm.  Derivative of B-spline basis function</header><div class="admonition-body"><p>The derivative of B-spline basis function can be expressed as follows:</p><p class="math-container">\[\begin{aligned}
\dot{B}_{(i,p,k)}(t)
&amp;=\frac{d}{dt}B_{(i,p,k)}(t) \\
&amp;=p\left(\frac{1}{k_{i+p}-k_{i}}B_{(i,p-1,k)}(t)-\frac{1}{k_{i+p+1}-k_{i+1}}B_{(i+1,p-1,k)}(t)\right)
\end{aligned}\]</p><p>Note that <span>$\dot{B}_{(i,p,k)}\in\mathcal{P}[p-1,k]$</span>.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Plots</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = 2</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; k = KnotVector(1:8)</code><code class="nohighlight hljs ansi" style="display:block;">KnotVector([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = BSplineSpace{p}(k)</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{2, Float64}(KnotVector([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot([t-&gt;bsplinebasis‚Ä≤‚Çä‚ÇÄ(P,i,t) for i in 1:dim(P)], 1, 8, ylims=(0,1))</code><code class="nohighlight hljs ansi" style="display:block;">Plot{Plots.GRBackend() n=5}</code></pre><p><img src="../img/bsplinebasisderivativeplot.png" alt/></p><h2 id="Partition-of-unity"><a class="docs-heading-anchor" href="#Partition-of-unity">Partition of unity</a><a id="Partition-of-unity-1"></a><a class="docs-heading-anchor-permalink" href="#Partition-of-unity" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Thm.  Partition of unity</header><div class="admonition-body"><p class="math-container">\[\begin{aligned}
\sum_{i}B_{(i,p,k)}(t) &amp;= 1 &amp; (k_{p+1} \le t &lt; k_{l-p}) \\
0 \le B_{(i,p,k)}(t) &amp;\le 1
\end{aligned}\]</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Plots</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = 2</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; k = KnotVector(1:8)</code><code class="nohighlight hljs ansi" style="display:block;">KnotVector([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = BSplineSpace{p}(k)</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{2, Float64}(KnotVector([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot(t-&gt;sum(bsplinebasis‚Çä‚ÇÄ(P,i,t) for i in 1:dim(P)), 1, 8, ylims=(0,1))</code><code class="nohighlight hljs ansi" style="display:block;">Plot{Plots.GRBackend() n=1}</code></pre><p><img src="../img/sumofbsplineplot.png" alt/></p><p>To satisfy the partition of unity on whole interval <span>$[1,8]$</span>, sometimes more knots will be inserted to the endpoints of the interval.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Plots</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = 2</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; k = KnotVector(1:8) + p * KnotVector([1,8])</code><code class="nohighlight hljs ansi" style="display:block;">KnotVector([1.0, 1.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 8.0, 8.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = BSplineSpace{p}(k)</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{2, Float64}(KnotVector([1.0, 1.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 8.0, 8.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot(t-&gt;sum(bsplinebasis‚Çä‚ÇÄ(P,i,t) for i in 1:dim(P)), 1, 8, ylims=(0,1))</code><code class="nohighlight hljs ansi" style="display:block;">Plot{Plots.GRBackend() n=1}</code></pre><p><img src="../img/sumofbsplineplot2.png" alt/></p><p>But, the sum <span>$\sum_{i} B_{(i,p,k)}(t)$</span> is not equal to <span>$1$</span> if <span>$t=8$</span>. Therefore, to satisfy partition of unity on closed interval <span>$[k_{p+1}, k_{l-p}]$</span>, the definition of first terms of B-spline basis functions are sometimes replaced:</p><p class="math-container">\[\begin{aligned}
{B}_{(i,0,k)}(t)
&amp;=
\begin{cases}
    &amp;1\quad (k_{i} \le t&lt;k_{i+1})\\
    &amp;1\quad (k_{i} &lt; t = k_{i+1}=k_{l})\\
    &amp;0\quad (\text{otherwise})
\end{cases}
\end{aligned}\]</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Plots</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = 2</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; k = KnotVector(1:8) + p * KnotVector([1,8])</code><code class="nohighlight hljs ansi" style="display:block;">KnotVector([1.0, 1.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 8.0, 8.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = BSplineSpace{p}(k)</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{2, Float64}(KnotVector([1.0, 1.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 8.0, 8.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot(t-&gt;sum(bsplinebasis(P,i,t) for i in 1:dim(P)), 1, 8, ylims=(0,1))</code><code class="nohighlight hljs ansi" style="display:block;">Plot{Plots.GRBackend() n=1}</code></pre><p><img src="../img/sumofbsplineplot3.png" alt/></p><h2 id="Inclusive-relation-between-B-spline-spaces"><a class="docs-heading-anchor" href="#Inclusive-relation-between-B-spline-spaces">Inclusive relation between B-spline spaces</a><a id="Inclusive-relation-between-B-spline-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Inclusive-relation-between-B-spline-spaces" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Thm.  Support of B-spline basis function</header><div class="admonition-body"><p>For proper B-spline spaces, the following relationship holds.</p><p class="math-container">\[\mathcal{P}[p,k]
\subseteq \mathcal{P}[p&#39;,k&#39;]
\Leftrightarrow (m=p&#39;-p \ge 0 \ \text{and} \ k+m\widehat{k}\subseteq k&#39;)\]</p></div></div><p>(as linear subspace..)</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; P1 = BSplineSpace{1}(KnotVector([1,3,5,8]))</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{1, Float64}(KnotVector([1.0, 3.0, 5.0, 8.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P2 = BSplineSpace{1}(KnotVector([1,3,5,6,8,9]))</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{1, Float64}(KnotVector([1.0, 3.0, 5.0, 6.0, 8.0, 9.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P3 = BSplineSpace{2}(KnotVector([1,1,3,3,5,5,8,8]))</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{2, Float64}(KnotVector([1.0, 1.0, 3.0, 3.0, 5.0, 5.0, 8.0, 8.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P1 ‚äÜ P2 # true</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P1 ‚äÜ P3 # true</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P2 ‚äÜ P3 # false</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P2 ‚äà P3 # true</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>Here are plots of the B-spline basis functions of the spaces <code>P1</code>, <code>P2</code>, <code>P3</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Plots</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P1 = BSplineSpace{1}(KnotVector([1,3,5,8]))</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{1, Float64}(KnotVector([1.0, 3.0, 5.0, 8.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P2 = BSplineSpace{1}(KnotVector([1,3,5,6,8,9]))</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{1, Float64}(KnotVector([1.0, 3.0, 5.0, 6.0, 8.0, 9.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P3 = BSplineSpace{2}(KnotVector([1,1,3,3,5,5,8,8]))</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{2, Float64}(KnotVector([1.0, 1.0, 3.0, 3.0, 5.0, 5.0, 8.0, 8.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot(
           plot([t-&gt;bsplinebasis‚Çä‚ÇÄ(P1,i,t) for i in 1:dim(P1)], 1, 9, ylims=(0,1), legend=false),
           plot([t-&gt;bsplinebasis‚Çä‚ÇÄ(P2,i,t) for i in 1:dim(P2)], 1, 9, ylims=(0,1), legend=false),
           plot([t-&gt;bsplinebasis‚Çä‚ÇÄ(P3,i,t) for i in 1:dim(P3)], 1, 9, ylims=(0,1), legend=false),
           layout=(3,1),
           link=:x
       )</code><code class="nohighlight hljs ansi" style="display:block;">Plot{Plots.GRBackend() n=11}</code></pre><p><img src="../img/subbsplineplot.png" alt/></p><p>This means, there exists a <span>$n \times n&#39;$</span> matrix <span>$A$</span> which holds:</p><p class="math-container">\[\begin{aligned}
B_{(i,p,k)}
&amp;=\sum_{j}A_{ij} B_{(j,p&#39;,k&#39;)} \\
n&amp;=\dim(\mathcal{P}[p,k]) \\
n&#39;&amp;=\dim(\mathcal{P}[p&#39;,k&#39;])
\end{aligned}\]</p><p>You can calculate the change of basis matrix <span>$A$</span> with <code>changebasis</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A12 = changebasis(P1,P2)</code><code class="nohighlight hljs ansi" style="display:block;">2√ó4 Matrix{Float64}:
 1.0  0.0  0.0       -0.0
 0.0  1.0  0.666667  -0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A13 = changebasis(P1,P3)</code><code class="nohighlight hljs ansi" style="display:block;">2√ó5 Matrix{Float64}:
 0.5  1.0  0.5  0.0  -0.0
 0.0  0.0  0.5  1.0   0.5</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Plots</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot(
           plot([t-&gt;bsplinebasis‚Çä‚ÇÄ(P1,i,t) for i in 1:dim(P1)], 1, 9, ylims=(0,1), legend=false),
           plot([t-&gt;sum(A12[i,j]*bsplinebasis‚Çä‚ÇÄ(P2,j,t) for j in 1:dim(P2)) for i in 1:dim(P1)], 1, 9, ylims=(0,1), legend=false),
           plot([t-&gt;sum(A13[i,j]*bsplinebasis‚Çä‚ÇÄ(P3,j,t) for j in 1:dim(P3)) for i in 1:dim(P1)], 1, 9, ylims=(0,1), legend=false),
           layout=(3,1),
           link=:x
       )</code><code class="nohighlight hljs ansi" style="display:block;">Plot{Plots.GRBackend() n=6}</code></pre><p><img src="../img/subbsplineplot2.png" alt/></p><h2 id="Multi-dimensional-B-spline"><a class="docs-heading-anchor" href="#Multi-dimensional-B-spline">Multi-dimensional B-spline</a><a id="Multi-dimensional-B-spline-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-dimensional-B-spline" title="Permalink"></a></h2><p>tensor product</p><p class="math-container">\[B_{i^1,\dots,i^d}(t^1,\dots,t^d)
=B_{(i^1,p^1,k^1)}(t^1)\cdots B_{(i^d,p^d,k^d)}(t^d)\]</p><h2 id="B-spline-manifold"><a class="docs-heading-anchor" href="#B-spline-manifold">B-spline manifold</a><a id="B-spline-manifold-1"></a><a class="docs-heading-anchor-permalink" href="#B-spline-manifold" title="Permalink"></a></h2><p>B-spline manifold is a parametric representation of a shape.</p><div class="admonition is-success"><header class="admonition-header">Def.  B-spline manifold</header><div class="admonition-body"><p>For given <span>$d$</span>-dimensional B-spline basis functions <span>$B_{i^1,\dots,i^d}$</span> and given points <span>$\bm{a}_{i^1,\dots,i^d} \in \mathbb{R}^{\hat{d}}$</span>, B-spline manifold is defined by following equality:</p><p class="math-container">\[\bm{p}(t^1,\dots,t^d;\bm{a}_{i^1,\dots,i^d})
=\sum_{i^1,\dots,i^d}B_{i^1,\dots,i^d}(t^1,\dots,t^d) \bm{a}_{i^1,\dots,i^d}\]</p><p>Where <span>$\bm{a}_{i^1,\dots,i^d}$</span> are called <strong>control points</strong>.</p></div></div><p>We will also write <span>$\bm{p}(t^1,\dots,t^d; \bm{a})$</span>, <span>$\bm{p}(t^1,\dots,t^d)$</span>, <span>$\bm{p}(t; \bm{a})$</span> or <span>$\bm{p}(t)$</span> for simplicity.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; P1 = BSplineSpace{1}(KnotVector([0,0,1,1]))</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{1, Float64}(KnotVector([0.0, 0.0, 1.0, 1.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P2 = BSplineSpace{1}(KnotVector([1,1,2,3,3]))</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{1, Float64}(KnotVector([1.0, 1.0, 2.0, 3.0, 3.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; n1 = dim(P1) # 2</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; n2 = dim(P2) # 3</code><code class="nohighlight hljs ansi" style="display:block;">3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = [[i, j] for i in 1:n1, j in 1:n2]  # n1 √ó n2 array of dÃÇ array.</code><code class="nohighlight hljs ansi" style="display:block;">2√ó3 Matrix{Vector{Int64}}:
 [1, 1]  [1, 2]  [1, 3]
 [2, 1]  [2, 2]  [2, 3]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = BSplineManifold(a, (P1, P2))</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching BSplineManifold(::Matrix{Vector{Int64}}, ::Tuple{BSplineSpace{1, Float64}, BSplineSpace{1, Float64}})
Closest candidates are:
  BSplineManifold(!Matched::Array{T, Dim‚Çä‚ÇÅ}, ::S) where {S&lt;:Tuple, Dim‚Çä‚ÇÅ, T&lt;:Real} at /home/runner/work/BasicBSpline.jl/BasicBSpline.jl/src/_BSplineManifold.jl:11</code></pre><h3 id="B-spline-curve"><a class="docs-heading-anchor" href="#B-spline-curve">B-spline curve</a><a id="B-spline-curve-1"></a><a class="docs-heading-anchor-permalink" href="#B-spline-curve" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ## 1-dim B-spline manifold
       p = 2 # degree of polynomial</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; k = KnotVector(1:12) # knot vector</code><code class="nohighlight hljs ansi" style="display:block;">KnotVector([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = BSplineSpace{p}(k) # B-spline space</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{2, Float64}(KnotVector([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = [[i-5, 3*sin(i^2)] for i in 1:dim(P)] # control points</code><code class="nohighlight hljs ansi" style="display:block;">9-element Vector{Vector{Float64}}:
 [-4.0, 2.5244129544236893]
 [-3.0, -2.2704074859237844]
 [-2.0, 1.2363554557252698]
 [-1.0, -0.8637099499951959]
 [0.0, -0.3970552502933191]
 [1.0, -2.9753365603293473]
 [2.0, -2.8612579582784154]
 [3.0, 2.7600781145903723]
 [4.0, -1.8896639828233615]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = BSplineManifold(a, (P,)) # Define B-spline manifold</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching BSplineManifold(::Vector{Vector{Float64}}, ::Tuple{BSplineSpace{2, Float64}})
Closest candidates are:
  BSplineManifold(!Matched::Array{T, Dim‚Çä‚ÇÅ}, ::S) where {S&lt;:Tuple, Dim‚Çä‚ÇÅ, T&lt;:Real} at /home/runner/work/BasicBSpline.jl/BasicBSpline.jl/src/_BSplineManifold.jl:11</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; save_png(&quot;1dim.png&quot;, M, unitlength = 50)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: save_png not defined</code></pre><p><img src="../img/1dim.png" alt/></p><h3 id="B-spline-surface"><a class="docs-heading-anchor" href="#B-spline-surface">B-spline surface</a><a id="B-spline-surface-1"></a><a class="docs-heading-anchor-permalink" href="#B-spline-surface" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = 2 # degree of polynomial</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; k = KnotVector(1:8) # knot vector</code><code class="nohighlight hljs ansi" style="display:block;">KnotVector([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = BSplineSpace{p}(k) # B-spline space</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{2, Float64}(KnotVector([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; rand_a = [rand(2) for i in 1:dim(P), j in 1:dim(P)]</code><code class="nohighlight hljs ansi" style="display:block;">5√ó5 Matrix{Vector{Float64}}:
 [0.763741, 0.800648]  [0.993819, 0.0083085]   ‚Ä¶  [0.991767, 0.704843]
 [0.84181, 0.295713]   [0.895983, 0.729179]       [0.446723, 0.636639]
 [0.294785, 0.759202]  [0.00623378, 0.865821]     [0.255196, 0.618821]
 [0.325791, 0.841028]  [0.967189, 0.335182]       [0.177858, 0.950048]
 [0.444855, 0.405115]  [0.493024, 0.337291]       [0.366657, 0.820096]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = [[2*i-6.5,2*j-6.5] for i in 1:dim(P), j in 1:dim(P)] + rand_a # random generated control points</code><code class="nohighlight hljs ansi" style="display:block;">5√ó5 Matrix{Vector{Float64}}:
 [-3.73626, -3.69935]  [-3.50618, -2.49169]   ‚Ä¶  [-3.50823, 4.20484]
 [-1.65819, -4.20429]  [-1.60402, -1.77082]      [-2.05328, 4.13664]
 [-0.205215, -3.7408]  [-0.493766, -1.63418]     [-0.244804, 4.11882]
 [1.82579, -3.65897]   [2.46719, -2.16482]       [1.67786, 4.45005]
 [3.94485, -4.09489]   [3.99302, -2.16271]       [3.86666, 4.3201]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = BSplineManifold(a,(P,P)) # Define B-spline manifold</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching BSplineManifold(::Matrix{Vector{Float64}}, ::Tuple{BSplineSpace{2, Float64}, BSplineSpace{2, Float64}})
Closest candidates are:
  BSplineManifold(!Matched::Array{T, Dim‚Çä‚ÇÅ}, ::S) where {S&lt;:Tuple, Dim‚Çä‚ÇÅ, T&lt;:Real} at /home/runner/work/BasicBSpline.jl/BasicBSpline.jl/src/_BSplineManifold.jl:11</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; save_png(&quot;2dim.png&quot;, M) # save image</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: save_png not defined</code></pre><p><img src="../img/2dim.png" alt/></p><h2 id="Affine-commutativity"><a class="docs-heading-anchor" href="#Affine-commutativity">Affine commutativity</a><a id="Affine-commutativity-1"></a><a class="docs-heading-anchor-permalink" href="#Affine-commutativity" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Thm.  Affine commutativity</header><div class="admonition-body"><p>If <span>$T$</span> is a affine transform <span>$\mathbb{R}^d\to\mathbb{R}^d$</span>, then the following equality holds.</p><p class="math-container">\[T(\bm{p}(t; \bm{a}))
=\bm{p}(t; T(\bm{a}))\]</p></div></div><h2 id="Refinement"><a class="docs-heading-anchor" href="#Refinement">Refinement</a><a id="Refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Refinement" title="Permalink"></a></h2><h3 id="h-refinemnet"><a class="docs-heading-anchor" href="#h-refinemnet">h-refinemnet</a><a id="h-refinemnet-1"></a><a class="docs-heading-anchor-permalink" href="#h-refinemnet" title="Permalink"></a></h3><p>Insert additional knots to knot vector.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; k‚Çä=(KnotVector(3.3,4.2),KnotVector(3.8,3.2,5.3)) # additional knotvectors</code><code class="nohighlight hljs ansi" style="display:block;">(KnotVector([3.3, 4.2]), KnotVector([3.2, 3.8, 5.3]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M_h = refinement(M,k‚Çä=k‚Çä) # refinement of B-spline manifold</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: M not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; save_png(&quot;2dim_h-refinement.png&quot;, M_h) # save image</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: save_png not defined</code></pre><p><img src="../img/2dim_h-refinement.png" alt/></p><p>Note that this shape and the last shape are identical.</p><h3 id="p-refinemnet"><a class="docs-heading-anchor" href="#p-refinemnet">p-refinemnet</a><a id="p-refinemnet-1"></a><a class="docs-heading-anchor-permalink" href="#p-refinemnet" title="Permalink"></a></h3><p>Increase the polynomial degree of B-spline manifold.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p‚Çä=(1,2) # additional degrees</code><code class="nohighlight hljs ansi" style="display:block;">(1, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M_p = refinement(M,p‚Çä=p‚Çä) # refinement of B-spline manifold</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: M not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; save_png(&quot;2dim_p-refinement.png&quot;, M_p) # save image</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: save_png not defined</code></pre><p><img src="../img/2dim_p-refinement.png" alt/></p><p>Note that this shape and the last shape are identical.</p><h2 id="Fitting"><a class="docs-heading-anchor" href="#Fitting">Fitting</a><a id="Fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting" title="Permalink"></a></h2><p>Least squares method.</p><p><a href="https://www.desmos.com/calculator/2hm3b1fbdf">Try on Desmos graphing graphing calculator!</a></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p1 = 2</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p2 = 2</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; k1 = KnotVector(-10:10)+p1*KnotVector(-10,10)</code><code class="nohighlight hljs ansi" style="display:block;">KnotVector([-10.0, -10.0, -10.0, -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 10.0, 10.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; k2 = KnotVector(-10:10)+p2*KnotVector(-10,10)</code><code class="nohighlight hljs ansi" style="display:block;">KnotVector([-10.0, -10.0, -10.0, -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 10.0, 10.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P1 = BSplineSpace{p1}(k1)</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{2, Float64}(KnotVector([-10.0, -10.0, -10.0, -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 10.0, 10.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P2 = BSplineSpace{p2}(k2)</code><code class="nohighlight hljs ansi" style="display:block;">BSplineSpace{2, Float64}(KnotVector([-10.0, -10.0, -10.0, -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 10.0, 10.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(u1, u2) = [2u1 + sin(u1) + cos(u2) + u2 / 2, 3u2 + sin(u2) + sin(u1) / 2 + u1^2 / 6] / 5</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a0 = fittingcontrolpoints(f, (P1, P2))</code><code class="nohighlight hljs ansi" style="display:block;">22√ó22 Matrix{Vector{Float64}}:
 [-5.05588, -2.50058]    [-5.06536, -2.29557]    ‚Ä¶  [-3.05588, 9.27797]
 [-4.95087, -2.88141]    [-4.96035, -2.6764]        [-2.95087, 8.89714]
 [-4.74724, -3.57959]    [-4.75671, -3.37459]       [-2.74724, 8.19896]
 [-4.37961, -4.12911]    [-4.38909, -3.92411]       [-2.37961, 7.64944]
 [-3.81531, -4.51363]    [-3.82479, -4.30862]       [-1.81531, 7.26492]
 [-3.20658, -4.80927]    [-3.21606, -4.60426]    ‚Ä¶  [-1.20658, 6.96928]
 [-2.74482, -5.11172]    [-2.7543, -4.90671]        [-0.744824, 6.66683]
 [-2.48703, -5.44949]    [-2.49651, -5.24448]       [-0.487032, 6.32906]
 [-2.30237, -5.75716]    [-2.31185, -5.55215]       [-0.302368, 6.02139]
 [-1.99289, -5.93575]    [-2.00237, -5.73075]       [0.00710538, 5.84279]
 ‚ãÆ                                               ‚ã±
 [-0.0308372, -5.62139]  [-0.0403156, -5.41639]     [1.96916, 6.15716]
 [0.153827, -5.52906]    [0.144348, -5.32405]       [2.15383, 6.24949]
 [0.411619, -5.3335]     [0.40214, -5.12849]     ‚Ä¶  [2.41162, 6.44505]
 [0.87338, -4.96928]     [0.863901, -4.76428]       [2.87338, 6.80927]
 [1.48211, -4.46492]     [1.47263, -4.25992]        [3.48211, 7.31363]
 [2.04641, -3.9161]      [2.03693, -3.7111]         [4.04641, 7.86245]
 [2.41403, -3.39896]     [2.40455, -3.19395]        [4.41403, 8.37959]
 [2.61767, -2.89714]     [2.60819, -2.69213]     ‚Ä¶  [4.61767, 8.88141]
 [2.72267, -2.6113]      [2.71319, -2.4063]         [4.72267, 9.16724]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = [a0[i1,i2][j] for i1 in 1:dim(P1), i2 in 1:dim(P2), j in 1:2]</code><code class="nohighlight hljs ansi" style="display:block;">22√ó22√ó2 Array{Float64, 3}:
[:, :, 1] =
 -5.05588    -5.06536    -4.87592   ‚Ä¶  -3.17592   -3.16536   -3.05588
 -4.95087    -4.96035    -4.77092      -3.07092   -3.06035   -2.95087
 -4.74724    -4.75671    -4.56728      -2.86728   -2.85671   -2.74724
 -4.37961    -4.38909    -4.19966      -2.49966   -2.48909   -2.37961
 -3.81531    -3.82479    -3.63536      -1.93536   -1.92479   -1.81531
 -3.20658    -3.21606    -3.02663   ‚Ä¶  -1.32663   -1.31606   -1.20658
 -2.74482    -2.7543     -2.56487      -0.864872  -0.854302  -0.744824
 -2.48703    -2.49651    -2.30708      -0.60708   -0.59651   -0.487032
 -2.30237    -2.31185    -2.12242      -0.422416  -0.411846  -0.302368
 -1.99289    -2.00237    -1.81294      -0.112942  -0.102373   0.00710538
  ‚ãÆ                                 ‚ã±              ‚ãÆ
 -0.0308372  -0.0403156   0.149115      1.84912    1.85968    1.96916
  0.153827    0.144348    0.333779      2.03378    2.04435    2.15383
  0.411619    0.40214     0.591571  ‚Ä¶   2.29157    2.30214    2.41162
  0.87338     0.863901    1.05333       2.75333    2.7639     2.87338
  1.48211     1.47263     1.66206       3.36206    3.37263    3.48211
  2.04641     2.03693     2.22636       3.92636    3.93693    4.04641
  2.41403     2.40455     2.59398       4.29398    4.30455    4.41403
  2.61767     2.60819     2.79762   ‚Ä¶   4.49762    4.50819    4.61767
  2.72267     2.71319     2.90262       4.60262    4.61319    4.72267

[:, :, 2] =
 -2.50058  -2.29557  -1.89194  ‚Ä¶  8.10171  8.66933  9.07297  9.27797
 -2.88141  -2.6764   -2.27277     7.72088  8.2885   8.69213  8.89714
 -3.57959  -3.37459  -2.97095     7.02269  7.59032  7.99395  8.19896
 -4.12911  -3.92411  -3.52047     6.47317  7.0408   7.44443  7.64944
 -4.51363  -4.30862  -3.90499     6.08866  6.65628  7.05992  7.26492
 -4.80927  -4.60426  -4.20062  ‚Ä¶  5.79302  6.36064  6.76428  6.96928
 -5.11172  -4.90671  -4.50308     5.49057  6.05819  6.46183  6.66683
 -5.44949  -5.24448  -4.84085     5.1528   5.72042  6.12405  6.32906
 -5.75716  -5.55215  -5.14852     4.84513  5.41275  5.81639  6.02139
 -5.93575  -5.73075  -5.32711     4.66653  5.23415  5.63779  5.84279
  ‚ãÆ                            ‚ã±                    ‚ãÆ
 -5.62139  -5.41639  -5.01275     4.98089  5.54852  5.95215  6.15716
 -5.52906  -5.32405  -4.92042     5.07323  5.64085  6.04448  6.24949
 -5.3335   -5.12849  -4.72486  ‚Ä¶  5.26879  5.83641  6.24005  6.44505
 -4.96928  -4.76428  -4.36064     5.633    6.20062  6.60426  6.80927
 -4.46492  -4.25992  -3.85628     6.13736  6.70499  7.10862  7.31363
 -3.9161   -3.7111   -3.30746     6.68618  7.25381  7.65744  7.86245
 -3.39896  -3.19395  -2.79032     7.20333  7.77095  8.17459  8.37959
 -2.89714  -2.69213  -2.2885   ‚Ä¶  7.70515  8.27277  8.6764   8.88141
 -2.6113   -2.4063   -2.00266     7.99098  8.5586   8.96224  9.16724</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = BSplineManifold(a, (P1, P2))</code><code class="nohighlight hljs ansi" style="display:block;">BSplineManifold{2, (2, 2), Float64, Tuple{BSplineSpace{2, Float64}, BSplineSpace{2, Float64}}, 3}((BSplineSpace{2, Float64}(KnotVector([-10.0, -10.0, -10.0, -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 10.0, 10.0])), BSplineSpace{2, Float64}(KnotVector([-10.0, -10.0, -10.0, -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 10.0, 10.0]))), [-5.0558768288980005 -5.06535522394003 ‚Ä¶ -3.165355223940022 -3.055876828897993; -4.950871885089599 -4.960350280131599 ‚Ä¶ -3.060350280131626 -2.950871885089592; ‚Ä¶ ; 2.6176667013971398 2.6081883063551174 ‚Ä¶ 4.508188306355132 4.617666701397136; 2.722671645205536 2.7131932501634983 ‚Ä¶ 4.6131932501635 4.7226716452055335]

[-2.5005780222443037 -2.295573078435923 ‚Ä¶ 9.072965508050826 9.277970451859208; -2.881408883673448 -2.676403939865049 ‚Ä¶ 8.692134646621662 8.897139590430095; ‚Ä¶ ; -2.897139590430078 -2.692134646621685 ‚Ä¶ 8.676403939865049 8.881408883673444; -2.6113037851925505 -2.4062988413841615 ‚Ä¶ 8.962239745102586 9.16724468891097])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; save_png(&quot;fitting.png&quot;, M, unitlength=50, xlims=(-10,10), ylims=(-10,10))</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: save_png not defined</code></pre><p><img src="../img/fitting_desmos.png" alt/> <img src="../img/fitting.png" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">¬´ Home</a><a class="docs-footer-nextpage" href="../contributing/">Contributing ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 30 December 2021 10:01">Thursday 30 December 2021</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
